class CSecondaryInputController inherit CInputController

	var string 					m_sTaskByMouseCursor;

	var ^CObjMgr		m_pxObjMgr;
	var bool			m_bLMB, m_bRMB;
	var point			m_xDragBoxBegin;
	var point			m_xMousePos;

	var int				m_iState;
	var string			m_sCommand;
	var string			m_sTTPath;

	var ^CObj			m_pxItem;

	var ^CObjSelection	m_pxSelection;

	var array string	m_asTargetTypes;
	var array string	m_asTargetOwner;
	var int				m_iPreviousCursor;

	var int m_iMT_Invalid;
	var int m_iMT_MouseMove;
	var int m_iMT_MouseLBtnDown;
	var int m_iMT_MouseRBtnDown;
	var int m_iMT_MouseLBtnUp;
	var int m_iMT_MouseRBtnUp;
	var int m_iMT_MouseLBtnDoubleClick;
	var int m_iMT_MouseRBtnDoubleClick;
	var int m_iMT_KeyDown;
	var int m_iMT_KeyUp;
	var int m_iMT_MouseWheel;

	var int m_iNumKeyDown;

	var ^CObj	m_pxMarkedObj;
	var ^CObjMgr.CRangeMarker	m_pxRangeMarker;
	var CClntHndl				m_xRangeMarkerObj;
	var bool					m_bMouseMarker;

	var CClntHndl m_xRepairObj;

	export constructor()
		m_iMT_Invalid=-1;
		m_iMT_MouseMove=0;
		m_iMT_MouseLBtnDown=1;
		m_iMT_MouseRBtnDown=2;
		m_iMT_MouseLBtnUp=3;
		m_iMT_MouseRBtnUp=4;
		m_iMT_MouseLBtnDoubleClick=5;
		m_iMT_MouseRBtnDoubleClick=6;
		m_iMT_KeyDown=7;
		m_iMT_KeyUp=8;
		m_iMT_MouseWheel=9;

		m_bMouseMarker = false;

		m_iNumKeyDown = -1;
		m_pxObjMgr=^(CClientWrap.GetObjMgr());
		m_iState = 0;
		m_sCommand = "";
		m_pxSelection=^(CClientWrap.GetSelection());
	endconstructor;

	export destructor()
	enddestructor;

	export proc void Reset()
		m_bMouseMarker = false;
		m_iNumKeyDown = -1;
		m_pxObjMgr=^(CClientWrap.GetObjMgr());
		m_iState = 0;
		m_sCommand = "";
		m_pxSelection=^(CClientWrap.GetSelection());
		ResetController();
	endproc;

	export proc void SetCommand(string p_s)
		m_sCommand = p_s;
	endproc;

	export proc void SetItem(CGuid p_xGuid)
		m_pxItem = CGameWrap.GetObjMgr().GetObj(p_xGuid);
	endproc;

	export proc void SetRangeMarker(string p_s, ^CObj p_pxObj)
		if(m_pxSelection^.NumEntries()>0)then
			m_pxMarkedObj=m_pxSelection^[0].GetObj();
			if(m_pxMarkedObj!=null)then
				if(p_s.Find("jetpack")!=(-1))then
					m_pxRangeMarker^.m_fRange=100.0f;
					m_pxRangeMarker^.m_fWidth1=0.5f;
					m_pxRangeMarker^.m_xColor1={{255,140,140,0}};
					m_pxRangeMarker^.m_xColor2={{255,150,150,0}};
				elseif(p_s.Find("Shotgunmove")!=(-1))then
					m_pxRangeMarker^.m_fRange=10.0f;
					m_pxRangeMarker^.m_fWidth1=0.5f;
					m_pxRangeMarker^.m_xColor1={{255,0,0,0}};
					m_pxRangeMarker^.m_xColor2={{255,200,0,0}};
				elseif(p_s.Find("Throwdownshot")!=(-1))then
					m_pxRangeMarker^.m_fRange=20.0f;
					m_pxRangeMarker^.m_xColor1={{255,0,0,0}};
					m_pxRangeMarker^.m_xColor2={{255,200,0,0}};
				elseif(p_s.Find("MickDundeeMove")!=(-1))then
					m_pxRangeMarker^.m_fRange=8.0f;
					m_pxRangeMarker^.m_xColor1={{0,0,255,0}};
					m_pxRangeMarker^.m_xColor2={{100,150,255,0}};
				elseif(p_s.Find("oracle")!=(-1))then
					m_pxRangeMarker^.m_fRange=20.0f;
					m_pxRangeMarker^.m_xColor1={{0,0,255,0}};
					m_pxRangeMarker^.m_xColor2={{100,150,255,0}};
				elseif(p_s.Find("Froze")>=0) then
					m_pxRangeMarker^.m_fRange=50.0f;
					m_pxRangeMarker^.m_xColor1={{0,0,255,0}};
					m_pxRangeMarker^.m_xColor2={{100,150,255,0}};
//				elseif(p_s.Find("Healing")!=(-1))then
//					m_pxRangeMarker^.m_fRange=50.0f;
//					m_pxRangeMarker^.m_xColor1={{0,255,255,0}};
//					m_pxRangeMarker^.m_xColor2={{100,255,100,0}};
				else
					m_pxRangeMarker^.m_bVisible=false;
				endif;
				/*
				KLog.LogError("RangeMarker","m_bVisible: "+m_pxRangeMarker^.m_bVisible.ToString());
				KLog.LogError("RangeMarker","m_fRange: "+m_pxRangeMarker^.m_fRange.ToString());
				KLog.LogError("RangeMarker","m_fWidth1: "+m_pxRangeMarker^.m_fWidth1.ToString());
				KLog.LogError("RangeMarker","m_fWidth1: "+m_pxRangeMarker^.m_fWidth1.ToString());
				KLog.LogError("RangeMarker","m_vPos: "+m_pxRangeMarker^.m_vPos.ToString());
				*/
			endif;
		endif;

	endproc;

	proc void AddRangeMarker(real p_fRange, bool p_bCursor, CClntHndl p_xObj)
		if(m_pxRangeMarker==null)then
			m_pxRangeMarker=m_pxObjMgr^.CreateRangeMarker();
		endif;
		if(p_bCursor)then
			m_bMouseMarker = true;
		endif;
		m_pxRangeMarker^.SetObject(p_xObj.GetObj());
		m_xRangeMarkerObj=p_xObj;
		m_pxRangeMarker^.m_fRange=p_fRange;
		m_pxRangeMarker^.m_fWidth1=0.5f;
		m_pxRangeMarker^.m_xColor1={{255,140,140,0}};
		m_pxRangeMarker^.m_xColor2={{255,150,150,100}};
		m_pxRangeMarker^.m_bVisible = true;
	endproc;

	export proc void SetNoneObjPath(string p_s)
		m_sTTPath = p_s;
		m_asTargetTypes = 0;
		m_asTargetOwner = 0;
		
		if(m_sTTPath.Find("MapPing")!=-1) then
			m_asTargetTypes.AddEntry("ALL ");
		endif;
	endproc;

	export proc void SetTTPath(string p_s)
		m_sTTPath = p_s;
		m_asTargetTypes = 0;
		m_asTargetOwner = 0;
		if(m_pxSelection^.NumEntries()<=0)then
			CMainController.Get().SetSecondaryInputController(false);
			return;
		endif;
		var ^CObj pxObj = m_pxSelection^[0].GetObj();
		if(pxObj==null)then
			CMainController.Get().SetSecondaryInputController(false);
			return;
		endif;
		var CTechTree xTechTree = pxObj^.GetTechTree();
		var bool bExceptions = m_sTTPath.Find("/DismountAll")>=0 || m_sTTPath.Find("/Repair")>=0;
		var ^CTechTree.CNode pxSecondary = xTechTree.FindNode(m_sTTPath+"/secondarycontroller");
		if(pxSecondary!=null)then

			var ^CTechTree.CNode pxSecondaryOwner = xTechTree.FindNode(m_sTTPath+"/secondarycontrollerowner");
			if(pxSecondaryOwner!=null)then
				var int i, iC = pxSecondaryOwner^.NumSubs();
				for(i=0)cond(i<iC)iter(i++)do
					m_asTargetOwner.AddEntry(pxSecondaryOwner^.GetSub(i)^.GetValue());
				endfor;
			endif;

			var int i, iC = pxSecondary^.NumSubs();
			for(i=0)cond(i<iC)iter(i++)do
				m_asTargetTypes.AddEntry(pxSecondary^.GetSub(i)^.GetValue());
			endfor;
			
		elseif(!bExceptions)then
			CMainController.Get().SetSecondaryInputController(false);
			return;
		endif;

		if(m_sTTPath.Find("DismountAll")!=-1) then
			m_asTargetTypes.AddEntry("VEC3");
		elseif(m_sTTPath.Find("/Resurrect")!=-1)then
			m_asTargetTypes=0;
			m_asTargetTypes.AddEntry("SPRT");
			//m_asTargetTypes.AddEntry("OTHR");
			//m_asTargetTypes.AddEntry("FOOD");
			return;
		elseif(m_sTTPath.Find("/Repair")>=0) then
			m_asTargetTypes.AddEntry("BLDG");
		endif;

		if(m_sTTPath.Find("/Attack")!=-1 && CGameInst.ms_xSelectionInfo.Has(CSelectionInfo.AREA_WEAPON))then
			var CClntHndl xInvalid;
			AddRangeMarker(CGameInst.ms_xSelectionInfo.m_fAreaRange, true, pxObj^.GetHandle());
		endif;
		
		if(m_sTTPath.Find("MapPing")!=-1) then
			
		endif;

	endproc;

	proc void SetMouseCursor(string p_sCursor)
		var int iCursor;
		iCursor = CCursorMgr.Get().GetSpecialCursor(p_sCursor,m_sTaskByMouseCursor);

		if (iCursor!=m_iPreviousCursor) then
			CClientWrap.GetDesktop()^.SetCursor(iCursor);
			m_iPreviousCursor=iCursor;
		endif;
	endproc;

	export proc bool HandleCatchedMsg(bitset p_dwType, bitset p_dwFlags, int p_iKey, int p_iX, int p_iY)
		return false;
	endproc;

	export proc bool HandleMsg(bitset p_dwType, bitset p_dwFlags, int p_iKey, int p_iX, int p_iY)
		if(p_dwType==CInputController.MT_Tick)then
			UpdateMouseCursor();
			if(m_bMouseMarker)then
				if(m_pxRangeMarker!=null)then
					var ^CObj pxObj = m_pxRangeMarker^.GetObject();
					if(m_xRangeMarkerObj.IsValid())then
						var vec3 v1Pos=CClientWrap.GetScapeMgr().GetPickPoint();
						var vec3 v2Pos=pxObj^.GetPos();
						var vec3 vPos = v1Pos-v2Pos;
						m_pxRangeMarker^.m_vPos=vPos;
					else
						CMainController.Get().SetSecondaryInputController(false);
					endif;
				endif;
			endif;
			return true;
		endif;
		var int i;
		if(p_dwType!=CInputController.MT_MouseMove)then
			if(p_dwType==CInputController.MT_MouseLBtnUp)then
				var vec3 vPickPoint = CClientWrap.GetScapeMgr().GetPickPoint();
				var CClntHndl xHitObj = CClientWrap.GetObjMgr().GetHitObj();
				var ^CObj pxObj = xHitObj.GetObj();
				if (pxObj!=null) then pxObj=pxObj^.GetGroupedParentObj(); endif;

				if(m_sCommand=="Walk")then
					var real fShifting=Math.Sqrt(m_pxSelection^.NumEntries().ToReal());
					var bool bPlaySound=false;
					for(i=0)cond(i<m_pxSelection^.NumEntries())iter(i++)do
						if(m_pxSelection^[i].IsValid())then
							var vec3 vShift;
							vShift.SetX(Random.MTRandF(-fShifting,fShifting));
							vShift.SetY(Random.MTRandF(-fShifting,fShifting));
							CEvt_GamePlayCommand.Send(m_pxSelection^[i], "Action", m_pxSelection^[i], vPickPoint+vShift, "/Walk");
							bPlaySound=true;
						endif;
					endfor;
					if (bPlaySound) then
						CGameInputController.ms_xUISoundMgr.PlayFeedbackSound(m_sTaskByMouseCursor);
					endif;
					CMainController.Get().SetSecondaryInputController(false);
				elseif(m_sCommand=="Attack")then
					if(	xHitObj.IsValid() && (	xHitObj.GetObj()^.GetType()=="CHTR"	|| xHitObj.GetObj()^.GetType()!="ANML"	|| xHitObj.GetObj()^.GetType()!="BLDG"))then
						var bool bPlaySound=false;
						if(pxObj!=null) then
							for(i=0)cond(i<m_pxSelection^.NumEntries())iter(i++)do
								if(m_pxSelection^[i].IsValid())then
									CEvt_GamePlayCommand.Send(m_pxSelection^[i], "Fight", pxObj^.GetHandle(), vPickPoint, "");
									bPlaySound=true;
								endif;
							endfor;
						endif;
						if (bPlaySound) then
							CGameInputController.ms_xUISoundMgr.PlayFeedbackSound(m_sTaskByMouseCursor);
						endif;
						CMainController.Get().SetSecondaryInputController(false);
					else
						var real fShifting=Math.Sqrt(m_pxSelection^.NumEntries().ToReal());
						var bool bPlaySound=false;
						for(i=0)cond(i<m_pxSelection^.NumEntries())iter(i++)do
							if(m_pxSelection^[i].IsValid())then
								var ^CAttribs pxAttr = m_pxSelection^[i].GetObj()^.GetAttribs();
								if (pxAttr!=null) then
									if (pxAttr^.GetValueInt("hitrange") > 0) then
										var CClntHndl xInvalid;
										CEvt_GamePlayCommand.Send(m_pxSelection^[i], "Fight", xInvalid, vPickPoint, "Scape");
										CGameInputController.ms_xUISoundMgr.PlayFeedbackSound(m_sTaskByMouseCursor);
										continue;
									endif;
								endif;
								var vec3 vShift;
								vShift.SetX(Random.MTRandF(-fShifting,fShifting));
								vShift.SetY(Random.MTRandF(-fShifting,fShifting));
								CEvt_GamePlayCommand.Send(m_pxSelection^[i], "Action", m_pxSelection^[i], vPickPoint+vShift, "/Walk");
								bPlaySound=true;
							endif;
						endfor;
						if (bPlaySound) then
							CGameInputController.ms_xUISoundMgr.PlayFeedbackSound(m_sTaskByMouseCursor);
						endif;
						CMainController.Get().SetSecondaryInputController(false);
					endif;
				elseif(m_sCommand == "Froze") then
					if (xHitObj.IsValid()) then
						var ^CObj pxO = xHitObj.GetObj();
						if (pxO^.GetType()!="SHIP") then xHitObj.Invalidate(); endif;

						m_pxObjMgr^.DeleteRangeMarkersForObj(m_pxMarkedObj);
						CMainController.Get().SetSecondaryInputController(false);
					endif;
					if (m_pxItem!=null) then
						CEvt_GamePlayCommand.Send(m_pxItem^.GetHandle(), "Froze", xHitObj, vPickPoint, "Froze");
						CGameInputController.ms_xUISoundMgr.PlayFeedbackSound(m_sTaskByMouseCursor);
					endif;
				elseif(m_sCommand=="MapPing") then
					var vec3 vPos=CClientWrap.GetScapeMgr().GetPickPoint();
					var ^CInGameScreen pxIngameScreen = CUIStateMgr.Get().GetInGameScreen();
					if(pxIngameScreen!=null)then
						var ^CMiniMapWindow2 pxMinimpap= pxIngameScreen^.GetMiniMapWindow();
						if(pxMinimpap!=null) then
							pxMinimpap^.SetMapPing(vPos);
						endif;
					endif;
					CMainController.Get().SetSecondaryInputController(false);
				else
					var	bool	bIsSpecial	=	false;
					var	string	sCharacter	=	"";
					var	string	sSpecial	=	"";

					if (m_sCommand=="Action") then
						if (m_sTTPath.Find("/DismountAll")>=0) then
							var int i, iC = m_pxSelection^.NumEntries();
							var bool bPlaySound=false;
							for(i=0) cond(i<iC) iter(++i) do
								var ^CObj pxO = m_pxSelection^[i].GetObj();
								if(pxO!=null) then
									CEvt_GamePlayCommand.Send(pxO^.GetHandle(), "Action", xHitObj, vPickPoint, "/PrepareUnboard");
									bPlaySound=true;
								endif;
							endfor;
							if (bPlaySound) then
								CGameInputController.ms_xUISoundMgr.PlayFeedbackSound(m_sTaskByMouseCursor);
							endif;
							CMainController.Get().SetSecondaryInputController(false);
							return true;
						elseif(m_sTTPath.Find("/hu_ladder")>=0) then
							var int i, iC = m_pxSelection^.NumEntries();
							var bool bPlaySound=false;
							for(i=0) cond(i<iC) iter(++i) do
								var ^CObj pxO = m_pxSelection^[i].GetObj();
								if(pxO!=null) then
									//L KLog.LogSpam("MaZi", "send");
									CEvt_GamePlayCommand.Send(pxO^.GetHandle(), m_sCommand, xHitObj, vPickPoint, m_sTTPath);
									bPlaySound=true;
								endif;
							endfor;
							if (bPlaySound) then
								CGameInputController.ms_xUISoundMgr.PlayFeedbackSound(m_sTaskByMouseCursor);
							endif;
							CMainController.Get().SetSecondaryInputController(false);
							return true;
						elseif(m_sTTPath.Find("/Repair")>=0) then
							var ^CObj pxRepairObj=xHitObj.GetObj();
							if(pxRepairObj!=null)then
								var int i, iC = m_pxSelection^.NumEntries();
								var bool bPlaySound=false;
								for(i=0) cond(i<iC) iter(++i) do
									var ^CObj pxO = m_pxSelection^[i].GetObj();
									if(pxO!=null) then
										var ^CAttribs pxAttribs = pxO^.GetAttribs();
										if(pxAttribs!=null && pxO^.GetTechTree().GetValueB(pxAttribs^.GetValue("ObjPath")+"/can_build",false))then
											CEvt_GamePlayCommand.Send(pxO^.GetHandle(), "Action", xHitObj, vPickPoint, "/Repair");
											bPlaySound=true;
										else
											CEvt_GamePlayCommand.Send(pxO^.GetHandle(), "Action", m_pxSelection^[i], vPickPoint, "/Walk");
										endif;
									endif;
								endfor;
								if (bPlaySound) then
									CGameInputController.ms_xUISoundMgr.PlayFeedbackSound(m_sTaskByMouseCursor);
								endif;
								CMainController.Get().SetSecondaryInputController(false);
							endif;
							return true;
						elseif(m_sTTPath.Find( "/Moves" ) >= 0 ) then
							var	int		iPosition	= m_sTTPath.FindRev( '/' );
							var	int		iLength		= (m_sTTPath.GetLength() - iPosition) - 1;
//							KLog.LogInfo( "DaHo", "m_sTTPath = " + m_sTTPath );
//							KLog.LogInfo( "DaHo", "iPosition = " + iPosition.ToString() );
//							KLog.LogInfo( "DaHo", "iLength = " + iLength.ToString() );
							if ( (iPosition >= 0) && (iLength > 0) ) then
								sSpecial	= m_sTTPath.Right( iLength );

//								KLog.LogInfo( "DaHo", "sSpecial = " + sSpecial );

								var	CTechTree			xTT		= CGameWrap.GetClient().GetPlayer().GetPlayerTechTree();
								var	^CTechTree.CNode	pxNodes	= xTT.FindNode( m_sTTPath + "/locations" );
								var	int					iI, iC	= pxNodes^.NumSubs();
								var	array string		asLocs;
								asLocs	= iC;

//								KLog.LogInfo( "DaHo", "Locations = " + iC.ToString() );

								for(iI=0)cond(iI<iC)iter(++iI) do
									var	^CTechTree.CNode pxNode = pxNodes^.GetSub( iI );

									if ( pxNode != null ) then
										asLocs[iI] = pxNode^.GetValue();
										asLocs[iI] = asLocs[iI].Right( asLocs[iI].GetLength() - 1 );
//										KLog.LogInfo( "DaHo", "Location " + iI.ToString() + " = " + asLocs[iI] );
									else
										asLocs[iI] = "";
									endif;
								endfor;

								iC = m_pxSelection^.NumEntries();
//								KLog.LogInfo( "DaHo", "Selection Count = " + iC.ToString() );

								for(iI=0)cond(iI<iC)iter(++iI) do
									var	^CObj	pxMyObj = m_pxSelection^[iI].GetObj();
									if ( pxMyObj == null ) then continue; endif;

//									KLog.LogInfo( "DaHo", "Testing Obj " + pxObj^.GetName() );

									var	^CAttribs	pxAttribs = pxMyObj^.GetAttribs();
									if ( pxAttribs == null ) then continue; endif;
//									KLog.LogInfo( "DaHo", "Obj has Attribs" );

									var	string	sTTPath = pxAttribs^.GetValue( "ObjPath" );
									if ( sTTPath.IsEmpty() ) then continue; endif;
//									KLog.LogInfo( "DaHo", "ObjPath =" + sTTPath );

									if ( asLocs.FindEntry( sTTPath ) != -1 ) then
										bIsSpecial = true;
										sCharacter = sTTPath.Right( (sTTPath.GetLength() - sTTPath.FindRev( '/' )) - 1 );
									endif;
								endfor;
							endif;
							if ( bIsSpecial ) then
//L								KLog.LogInfo( "DaHo", "bIsSpecial = true" );
//L								KLog.LogInfo( "DaHo", "sSpecial   = " + sSpecial );
//L								KLog.LogInfo( "DaHo", "sCharacter = " + sCharacter );
							endif;
						endif;
					endif;
					
					var bool bAllTypes=false;
					
					if(m_asTargetTypes.FindEntry("ALL ")!=-1)then
						bAllTypes=true;
					endif;
					
					if(pxObj==null && !bAllTypes && m_asTargetTypes.FindEntry("VEC3")==-1)then
//L						KLog.LogInfo( "DaHo", "Early Exit!" );
						return true;
					elseif(pxObj!=null)then
						if(!bAllTypes && m_asTargetTypes.FindEntry(pxObj^.GetType().AsString())==-1)then
//L							KLog.LogInfo( "DaHo", "Early Exit!!" );
							return true;
						else

							if(m_asTargetOwner.NumEntries()>0)then
								var bool bOwner		= pxObj^.GetOwner() == CGameWrap.GetClient().GetPlayerID();
								var int iStatus = CGameWrap.GetDiplomacyMgr().GetMyOpinion(pxObj^.GetOwner());
								var bool bEnemy		= iStatus==0;
								var bool bNeutral	= iStatus==1;
								var bool bAlly		= iStatus==2;

								if(bOwner && m_asTargetOwner.FindEntry("Owner")==-1)then
									return true;
								endif;
								if(!bOwner)then
									if(bAlly && m_asTargetOwner.FindEntry("Allies")==-1)then
										return true;
									endif;
									if(bNeutral && m_asTargetOwner.FindEntry("Neutrals")==-1)then
										return true;
									endif;
									if(bEnemy && m_asTargetOwner.FindEntry("Enemies")==-1)then
										return true;
									endif;
								endif;
							endif;
						endif;
					endif;
					var CClntHndl xHndl;
					if(pxObj!=null)then
						xHndl = pxObj^.GetHandle();
					endif;
					if(m_sTTPath.Find("/Walk")!=-1 || m_sTTPath.Find("/AggressiveTarget")!=-1 || m_sTTPath.Find("/Attack")!=-1)then
						var vec3 vDir = m_pxSelection^.GetPos() - vPickPoint;
						var real fDir=Math.ATan2(vDir.GetX(),vDir.GetY());
						m_sTTPath += " /FrmDir="+fDir.ToString();
						m_sTTPath += " /FrmSpc=2.7807";
					endif;

					var CObjList xList;
					for(i=0)cond(i<m_pxSelection^.NumEntries())iter(i++)do
						if(m_pxSelection^[i].IsValid())then
							xList.Include(m_pxSelection^[i]);
						endif;
					endfor;
					if(m_sTTPath.Find("/Resurrect")!=-1)then
						if(pxObj!=null)then
							var int iSpiritHandle=CGameWrap.GetSpiritMgr().GetSpiritHandle(pxObj);
							if(iSpiritHandle!=-1)then
								m_sTTPath+=" "+iSpiritHandle.ToString();
							endif;
						endif;
					endif;
					CEvt_GamePlayCommand.Send(xList, m_sCommand, xHndl, vPickPoint, m_sTTPath);

//L					KLog.LogInfo( "DaHo", "Kacke?! = " + m_sTTPath );

					if ( bIsSpecial ) then
//L						KLog.LogInfo( "DaHo", "Playing Special " + sSpecial + " for Character " + sCharacter );
						CGameInputController.ms_xUISoundMgr.PlayFeedbackSoundEvent( "voice_" + sCharacter + "_special_" + sSpecial, "", CSoundMgrCln.SOUND_VOLTRACK_GLOBAL );
					else
						//L KLog.LogInfo("UISound","secondary "+m_sCommand+" "+m_sTTPath);
						CGameInputController.ms_xUISoundMgr.PlayFeedbackSound(m_sTaskByMouseCursor);
					endif;

					//HACK RT#6839 Urs/Interface - Beim von der Mauer springen gibt es keinen Zielpunkt-Feedback-Effekt
					if(m_sTTPath.Find("JumpOffWall")==-1)then
						CClientWrap.GetScapeMgr().AddScapeFeedbackPing(vPickPoint);
					endif;
					//END HACK

					m_pxObjMgr^.DeleteRangeMarkersForObj(m_pxMarkedObj);
					CMainController.Get().SetSecondaryInputController(false);
				endif;
			endif;
			if(p_dwType==CInputController.MT_MouseRBtnUp)then
				m_pxObjMgr^.DeleteRangeMarkersForObj(m_pxMarkedObj);
				CMainController.Get().SetSecondaryInputController(false);
				return true;
			endif;
			if(p_dwType==CInputController.MT_MouseLBtnDown)then
				return true;
			endif;
			//CMainController.Get().SetSecondaryInputController(false);
		endif;

		return false;
	endproc;

	proc void UpdateMouseCursor()
		var CClntHndl xHitObj	= CClientWrap.GetObjMgr().GetHitObj();
		var vec3 vPickPoint		= CClientWrap.GetScapeMgr().GetPickPoint();

		SetMouseCursor(GetAction(CGameInst.ms_xSelectionInfo, xHitObj, vPickPoint));

	endproc;

	proc string GetAction(ref CSelectionInfo p_rxSel, CClntHndl p_xHitObj, vec3 p_vPickPoint)
		var ^CObj pxObj = p_xHitObj.GetObj();
		var string sHitType;
		if(pxObj!=null)then
			pxObj = pxObj^.GetGroupedParentObj();
			sHitType = pxObj^.GetType().AsString();
		else
			sHitType = "VEC3";
		endif;
		if(m_asTargetTypes.FindEntry("ALL ")==-1 && m_asTargetTypes.FindEntry(sHitType)==-1)then
			return "no";
		endif;

		if(pxObj!=null)then
			if(m_asTargetOwner.NumEntries()>0)then
				var bool bOwner		= pxObj^.GetOwner() == CGameWrap.GetClient().GetPlayerID();
				var int iStatus = CGameWrap.GetDiplomacyMgr().GetMyOpinion(pxObj^.GetOwner());
				var bool bEnemy		= iStatus==0;
				var bool bNeutral	= iStatus==1;
				var bool bAlly		= iStatus==2;

				if(bOwner && m_asTargetOwner.FindEntry("Owner")==-1)then
					return "no";
				endif;
				if(!bOwner)then
					if(bAlly && m_asTargetOwner.FindEntry("Allies")==-1)then
						return "no";
					endif;
					if(bNeutral && m_asTargetOwner.FindEntry("Neutrals")==-1)then
						return "no";
					endif;
					if(bEnemy && m_asTargetOwner.FindEntry("Enemies")==-1)then
						return "no";
					endif;
				endif;
			endif;
		endif;

		if(m_sTTPath.Find("MapPing")!=-1) then
			return "mapping";
		endif;

		if(m_sTTPath.Find("Moves/CHTR/jetpack")!=-1) then
			//MAX JUMP DISTANCE = 100
			if((p_vPickPoint-CClientWrap.GetSelection().GetPos()).Abs2S()>10000.0)then
				return "no";
			else
				return "special";
			endif;
		endif;
		//Henry: set a special cursor for the build ladder action
		if(m_sTTPath.Find("/hu_ladder")>=0) then
			if(p_xHitObj.IsValid())then
				var ^CObj pxHitObj = p_xHitObj.GetObj();
				var ^CAttribs pxAttr = pxHitObj^.GetAttribs();
				if(pxAttr==null)then return ""; endif;
				if(pxAttr^.GetValueInt("IsDockable")==1 && pxHitObj^.IsEnemy())then
					return "special";
				else
					return "no";
				endif;
			endif;
		endif;
		if(m_sTTPath.Find("/Attack")!=-1)then
			var string sReturn = "attack";
			if(p_rxSel.m_xMaxRangeObj.IsValid())then
				var ^CObj pxMaxRangeObj = p_rxSel.m_xMaxRangeObj.GetObj();
				var real fObjSize = pxMaxRangeObj^.GetCollisionRadius();

				var vec3 vPos = p_vPickPoint;
				var vec3 vHitSize;
				if(p_xHitObj.IsValid())then
					var ^CObj pxHitObj = p_xHitObj.GetObj();
					vPos=pxHitObj^.GetPos();

					vHitSize+=pxHitObj^.GetSize();
					vHitSize.SetZ(0.0);
					vHitSize*=0.5;

				endif;

				var real fRange = (fObjSize+vHitSize.Abs())+p_rxSel.m_fMaxRange;
				var real fMinRange = (p_rxSel.m_fMinRange+fObjSize);
				var real fDistance = (vPos-pxMaxRangeObj^.GetPos()).Abs();

				if(CGameInst.ms_xSelectionInfo.Has(CSelectionInfo.AREA_WEAPON))then
					sReturn += "_area_weapon";
					if(fDistance < fMinRange)then
						sReturn += "_invalid";
					endif;
				endif;

				if(fDistance > fRange)then
					sReturn += "_walk";
				endif;
			endif;
			return sReturn;
		elseif(m_sTTPath.Find("/AggressiveTarget")!=-1)then
			return "walk_aggro";
		elseif(m_sTTPath.Find("/Walk")!=-1)then
			return "walk";
		elseif(m_sTTPath.Find("/DismountAll")!=-1)then
			return "unload";
		elseif(m_sTTPath.Find("/Moves/")!=-1)then
			return "special";
		elseif(m_sTTPath.Find("/Repair")>=0) then
			var ^CAttribs pxA = pxObj^.GetAttribs();
			if(pxA!=null) then
				var int iHP = pxA^.GetValueInt("hitpoints");
				var int iMaxHP = pxA^.GetValueInt("maxhitpoints");
				if(iHP<iMaxHP) then
					return "build";
				else
					return "no";
				endif;
			endif;
		elseif
		(
			(
				m_sTTPath.Find("Build/SHIP/ninigi_mineship_mine")>=0 ||
				m_sTTPath.Find("Build/SHIP/ninigi_water_turret")>=0
			) &&
			CClientWrap.GetScapeMgr().GetHeight(p_vPickPoint.GetX(),p_vPickPoint.GetY())<=CClientWrap.GetScapeMgr().GetSeaLevel()
		) then
			return "special";
		endif;
		return "";
	endproc;

	export proc void ResetController()
	m_bMouseMarker = false;
	if(m_pxRangeMarker!=null)then
		CClientWrap.GetObjMgr().DeleteAllRangeMarkers();
	endif;
	m_pxRangeMarker = null;
	SetMouseCursor("");
	endproc;
	
	export proc string GetCommand()
		return m_sCommand;
	endproc;
endclass;

