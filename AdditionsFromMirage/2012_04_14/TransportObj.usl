class CTransportObj inherit CFightingObj

	class CHPManager

		export constructor()
		endconstructor;

		export destructor()
		enddestructor;

		export var real m_fHitpoints;
		export var real m_fMaxHitpoints;

		export proc void DoKArc(ref CArc p_rxArc)
			p_rxArc << m_fHitpoints;
			p_rxArc << m_fMaxHitpoints;
		endproc;

	endclass;

	// KArc version
	export const int KARCVERSION = 14;

	//Captain stuff
	var CObjHndl				m_xCaptain;						///! Handle of the captain

	//Passengers stuff
	var CObjList				m_xPassengers;					///! List of all passengers
	var CObjList				m_xPotentialPassengers;			///! List of all passengers, that are about to enter the transporter
	var int						m_iBlockedSlots;				///! Slots blocked by Passengers of boarded Transporters
	var int						m_iPotentiallyBlockedSlots;		///! Slots blocked by Passengers of boarded Transporters
	var bool					m_bReleaseWhileDying;			///! when dying, and there's no possibility to unboard the passengers, just release them
	export const real			m_fMaxPassengerDropRadius = 30.0f; ///! passengers can unboard within this radius if the area is valid for unboarding
	export const real			m_fPassengerSpreadRadius = 10.0f; ///! if final destination of disembark all command lies within a circle of radius m_fPassengerSpreadRadius around the transporter, disembarked units will spread (cosmetic feature)

	//Buildup stuff
	var	int			 			m_iBuildUpType;					///! Type of BuildUp, see BuildUpBase.usl for details
	var array int				m_aiAdditionalBuildUps;
	var	^CBuildUpBase 			m_pxBuildUp;					///! pointer to a BuildUp
	var array ^CBuildUpBase		m_apxAdditionalBuildUps;
	const int					TIMER_BUILDUP_BUSY	= 452;
	export var procref<void>	m_xOnBusyTimer;

	//TechTree stats
	var int						m_iMaxPassengers;
	var string					m_sCaptainClass;
	var int						m_iNeededLevel;
	var string					m_sCaptainAnim;
	var string					m_sCaptainAttackAnim;

	//Miscellaneous
	var ^CTaskHook				m_pxTaskHook;
	var string 					m_sCurFlagDesc;

	//Resource stuff
	var real					m_fResInv;
	var real					m_fResInvCap;
	var real					m_fResInvStone;
	var bool					m_bLinkOccupied;

	//Idle stuff
	var CGameTime				m_xIdleStartTime;
	var int						m_iIdleTimer;
	var string					m_sLastTask;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);

		var CFourCC xBase="TOba"; //TransportObj base
		var int iVersion = KARCVERSION; // !!! be really carefull if you change something here (version shared with CSeasCarrier)
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());

		m_xPassengers.DoKArc(pxArc^);
		m_xCaptain.DoKArc(pxArc^);
		(pxArc^) << m_iMaxPassengers;
		(pxArc^) << m_fResInv;

		(pxArc^) << m_iBuildUpType;
		if(HasBuildUp())then
			GetBuildUp()^.DoKArc(pxArc^, iVersion);
		endif;
		var int i, iC = m_aiAdditionalBuildUps.NumEntries();
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			(pxArc^) << m_aiAdditionalBuildUps[i];
			if(HasAdditionalBuildUp(i))then
				m_apxAdditionalBuildUps[i]^.DoKArc(pxArc^, iVersion);
			endif;
		endfor;

		m_xPotentialPassengers.DoKArc(pxArc^);
		(pxArc^) << m_iBlockedSlots;
		(pxArc^) << m_iPotentiallyBlockedSlots;
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="TOba")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVer=p_pxReaderNode^.GetVersion();
			if(iVer>=7)then
				m_xPassengers.DoKArc(pxArc^);
				m_xCaptain.DoKArc(pxArc^);
				(pxArc^) << m_iMaxPassengers;
				(pxArc^) << m_fResInv;

				(pxArc^) << m_iBuildUpType;
				if(HasBuildUp())then
					SetBuildUp(m_iBuildUpType);
					GetBuildUp()^.DoKArc(pxArc^, iVer);
				endif;

				var int i, iC;
				(pxArc^) << iC;
				m_aiAdditionalBuildUps = iC;
				for(i=0)cond(i<iC)iter(i++)do
					(pxArc^) << m_aiAdditionalBuildUps[i];
					SetAdditionalBuildUp(m_aiAdditionalBuildUps[i]);
					if(HasAdditionalBuildUp(i))then
						GetAdditionalBuildUp(i)^.DoKArc(pxArc^, iVer);
					else
						m_apxAdditionalBuildUps.AddEntry(null);
					endif;
				endfor;
				if(iVer>=13)then
					m_xPotentialPassengers.DoKArc(pxArc^);
					(pxArc^) << m_iBlockedSlots;
					(pxArc^) << m_iPotentiallyBlockedSlots;
				endif;
			else
				var CObjHndl xInvalid;
				var CObjList xInvalidOL;
				var CHPManager xInvalidMgr;
				var int iInvalid;
				var real fInvalid;
				var array CTmpLinkSlot axInvalid;
				if(iVer<5) then
					xInvalidOL.DoKArc(pxArc^);
					xInvalid.DoKArc(pxArc^);
					(pxArc^) << iInvalid;
					(pxArc^) << iInvalid;
					(pxArc^) << fInvalid;
					if(iVer>=4) then (pxArc^) << fInvalid; endif;
					xInvalidMgr.DoKArc(pxArc^);
					xInvalidMgr.DoKArc(pxArc^);
					if(p_pxReaderNode^.GetVersion() > 1) then
						var int i, iC;
						(pxArc^) << iC;
						axInvalid = iC;
						for (i=0) cond(i<iC) iter(++i) do
							axInvalid[i].DoKArc(pxArc^);
						endfor;
					endif;
				else
					if(iVer>4) then
						xInvalidOL.DoKArc(pxArc^);
						xInvalid.DoKArc(pxArc^);
						(pxArc^) << iInvalid;
						(pxArc^) << iInvalid;
						(pxArc^) << fInvalid;
						if(iVer>=4) then (pxArc^) << m_fResInv; endif;
						xInvalid.DoKArc(pxArc^);
						xInvalidMgr.DoKArc(pxArc^);
						xInvalidMgr.DoKArc(pxArc^);
						if(p_pxReaderNode^.GetVersion() > 1) then
							var int i, iC;
							(pxArc^) << iC;
							axInvalid = iC;
							for (i=0) cond(i<iC) iter(++i) do
								axInvalid[i].DoKArc(pxArc^);
							endfor;
						endif;
					endif;
					if(iVer>5)then
						xInvalid.DoKArc(pxArc^);
					endif;
				endif;
			endif;
		elseif(p_pxReaderNode^.GetType()=="TObu")then
			var CObjHndl xInvalid;
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			xInvalid.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;


	constructor()
		m_pxBuildUp = null;
		m_iMaxPassengers = 0;
		m_pxTaskHook = null;
		m_bLinkOccupied = false;
		m_fResInvCap = 150.0;
		m_iBlockedSlots = 0;
		m_iPotentiallyBlockedSlots = 0;
	endconstructor;


	destructor()
		DestroyBuildUp();
		delete m_pxTaskHook;
	enddestructor;


	export proc void OnActionStart()
		super.OnActionStart();
		if(HasBuildUp())then
			GetBuildUp()^.OnActionStart();
		endif;
	endproc;

	export proc void OnActionEnd(bool p_bBroken)
		super.OnActionEnd(p_bBroken);
		if(HasBuildUp())then
			GetBuildUp()^.OnActionEnd();
		endif;
	endproc;

	proc bool SetResInvCap(real p_fResInvCap)
		m_fResInvCap=p_fResInvCap;
		return(true);
	endproc;

	proc void HarvestTask(^CGameObj p_pxObject, vec3 p_vPos)
		GoTo(p_vPos, true, GetDefaultSpeed(), true, true);
	endproc;

	proc void MineTask(^CGameObj p_pxObject, vec3 p_vPos)
		GoTo(p_vPos, true, GetDefaultSpeed(), true, true);
	endproc;

	proc void GetFoodTask(^CGameObj p_pxObject, vec3 p_vPos)
		GoTo(p_vPos, true, GetDefaultSpeed(), true, true);
	endproc;

	export proc void DoCutAnim()
		//AnimAction("");
	endproc;

	export proc void DoMineAnim()
		//AnimAction("");
	endproc;

	export proc void DoTakeAnim()
		//AnimAction("");
	endproc;

	export proc void LinkToStock(string p_sGFX)
		m_bLinkOccupied = true;
		//??LinkGfx("");
	endproc;

	export proc void ClearLink()
		m_bLinkOccupied = false;
		//??LinkGfx("");
	endproc;

	export proc bool LinkOccupied()
		return m_bLinkOccupied;
	endproc;

	export proc real GetResInv()
		if(m_bLinkOccupied)then
			return m_fResInv;
		endif;
		return 0.0;
	endproc;

	export proc real GetResInvStone()
		if(m_bLinkOccupied)then
			return m_fResInvStone;
		endif;
		return 0.0;
	endproc;

	export proc real GetResInvCap()
		return m_fResInvCap;
	endproc;


	export proc void SetResInv(real p_fValue)
		m_fResInv = p_fValue;
	endproc;

	export proc void SetResInvStone(real p_fValue)
		m_fResInvStone = p_fValue;
	endproc;

	export proc bool CheckInResInv()
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CBasePlayer pxPlayer=cast<CBasePlayer>(pxLevel^.GetPlayer(GetOwner()));
		if(pxPlayer==null)then return false; endif;

		var real fOriginalValue=m_fResInv;
		var real fReturnValue=pxPlayer^.AddResource("wood",m_fResInv);

		var real fStatisticValue=fOriginalValue;
		if(fReturnValue!=0.0)then fStatisticValue-=fReturnValue; endif;

		m_fResInv=fReturnValue;

		// collect checked in ressource for statistics
//		var ^CStatisticMgr pxStatisticMgr=^(pxLevel^.GetStatisticMgr());
//		var CGameTime xTime=CTimeMgr.Get().GetTime();
//		pxStatisticMgr^.AddSample( CStatisticSample.Collected_Wood.ToInt(), GetOwner(), fStatisticValue.ToInt() );
		return (fReturnValue!=fOriginalValue) || (fReturnValue==0.0);
	endproc;


	export proc bool CheckInResInvStone()
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CBasePlayer pxPlayer=cast<CBasePlayer>(pxLevel^.GetPlayer(GetOwner()));
		if(pxPlayer==null)then return false; endif;
		
		var real fOriginalValue=m_fResInvStone;
		var real fReturnValue=pxPlayer^.AddResource("stone",m_fResInvStone);

//		KLog.LogSpam("JaNe","fOriginalValue="+fOriginalValue.ToString());
//		KLog.LogSpam("JaNe","fReturnValue="+fReturnValue.ToString());


		var real fStatisticValue=fOriginalValue;
		if(fReturnValue!=0.0)then fStatisticValue-=fReturnValue; endif;

		m_fResInvStone=fReturnValue;

		// collect checked in ressource for statistics
//		var ^CStatisticMgr pxStatisticMgr=^(pxLevel^.GetStatisticMgr());
//		var CGameTime xTime=CTimeMgr.Get().GetTime();
//
//		pxStatisticMgr^.AddSample( CStatisticSample.Collected_Stone.ToInt(), GetOwner(), fStatisticValue.ToInt() );

		return fReturnValue!=fOriginalValue || fReturnValue==0.0;
	endproc;


	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		RegisterFlockingBoid();
		if (!p_bLoad) then
			SetTransportClass(0);
			SetSelectable(true);
			SetHitable(true);
		endif;

		m_pxTaskHook = new CTaskHook(this);
        m_pxTaskMgr^.Subscribe(m_pxTaskHook);

	endproc;

	export proc void OnPostLoad()

		super.OnPostLoad();

		LinkCaptainObj();

		if(HasBuildUp())then
			GetBuildUp()^.OnPostLoad();
			GetBuildUp()^.UpdateLinkedObjs();
			GetBuildUp()^.EnableLinkedObjs();
		endif;

		var int i, iC = NumAdditionalBuildUps();
		for(i=0)cond(i<iC)iter(i++)do
			if(HasAdditionalBuildUp(i))then
				GetAdditionalBuildUp(i)^.OnPostLoad();
				GetAdditionalBuildUp(i)^.UpdateLinkedObjs();
				GetAdditionalBuildUp(i)^.EnableLinkedObjs();
			endif;
		endfor;

	endproc;


	export proc void StopEverything()
		super.StopEverything();
		StopBuildUpFighting();
	endproc;

	export proc void StopBuildUpFighting()
		if(HasBuildUp(CBuildUpBase.TYPE_WEAPON) || HasBuildUp(CBuildUpBase.TYPE_WEAPON_TRANSPORTER))then
			var ^CBuildUpWeapon pxWeapon = cast<CBuildUpWeapon>(GetBuildUp());
			if(pxWeapon^.GetAutoAttack())then
				pxWeapon^.StopFighting();
			endif;
		endif;
		var int i, iC = NumAdditionalBuildUps();
		for(i=0)cond(i<iC)iter(i++)do
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(i))^.StopFighting();
		endfor;
	endproc;


	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if (p_rxEvtPtr.GetClass() == ms_xTimerClass) then
			var int iTimerID = p_rxEvtPtr.GetInt(0);
			if(iTimerID==TIMER_BUILDUP_BUSY)then
				DeleteTimer(TIMER_BUILDUP_BUSY);
				if(!m_xOnBusyTimer.IsNull())then
					m_xOnBusyTimer.Call();
				endif;
			elseif (iTimerID == TIMER_AGGRO ) then
				if(HasBuildUp(CBuildUpBase.TYPE_WEAPON) || HasBuildUp(CBuildUpBase.TYPE_WEAPON_TRANSPORTER))then
					cast<CBuildUpWeapon>(GetBuildUp())^.StartFightingTask(false);
				endif;
				var int i, iC = NumAdditionalBuildUps();
				for(i=0)cond(i<iC)iter(i++)do
					cast<CBuildUpWeapon>(GetAdditionalBuildUp(i))^.StartFightingTask(false);
				endfor;
				super.HandleEvent(p_rxEvtPtr);
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;


	export proc void OnIdleEnter(^CState p_pxFrom, ^CState p_pxTo)
		m_xIdleStartTime = CTimeMgr.Get().GetTime();
		m_iIdleTimer = -1; //init state
		super.OnIdleEnter(p_pxFrom,p_pxTo);
	endproc;

    export proc void OnIdleTick(int p_iTime)
		if(m_iIdleTimer==-1)then
			//init state
			if(m_sLastTask == "Fight")then
				m_iIdleTimer = 0;
			elseif(m_sLastTask == "Walk2Pos")then
				m_iIdleTimer = 1;
			else
				m_iIdleTimer = 100;
			endif;
		endif;

		var CGameTime xNow = CTimeMgr.Get().GetTime();
		var real fDuration = (xNow-m_xIdleStartTime).GetSecondsF();
		if(fDuration > 2.0)then
			var ^CAttribs pxAttr = GetAttribs();
			if(pxAttr!=null)then
				if(pxAttr^.GetValue("CurTask")!="Idle")then
					pxAttr^.SetValue("CurTask","Idle");
				endif;
				SetTaskDescription("idle");
			endif;
		elseif(fDuration>0.3)then
			SetTaskDescription("");
		endif;
		super.OnIdleTick(p_iTime);
	endproc;

    proc void OnChangeToIdleState(string p_sTaskName)
    	m_sLastTask = p_sTaskName;
	endproc;

	export proc void ProjectileOn()
		if(GetProjectile().IsEmpty())then return; endif;
		if(HasBuildUp())then
			var ^CGameObj pxObj = GetBuildUp()^.GetPrimaryLinkedObj().GetObj();
			if(pxObj==null)then return; endif;

			var CFourCC xLink = "psh1"; var vec3 vP;
			if(pxObj^.GetLinkPosObj(xLink, vP))then
				pxObj^.SetLinkGFX(xLink, GetProjectile()+GetWeaponMgr()^.GetRightHVariationPostfix());
				return;
			endif;
		else
			super.ProjectileOn();
		endif;
	endproc;


	export proc bool SetLevelClean(int p_iLevel)
		var bool bReturn = super.SetLevelClean(p_iLevel);
		if(HasBuildUp(CBuildUpBase.TYPE_WEAPON) || HasBuildUp(CBuildUpBase.TYPE_WEAPON_TRANSPORTER))then
			cast<CBuildUpWeapon>(GetBuildUp())^.UpdateWeapon();
		endif;

		var ^CCaptain pxCaptain = cast<CCaptain>(m_xCaptain.GetObj());
		if(pxCaptain!=null)then
			pxCaptain^.UpdateGfx();
		endif;

		var int i, iC = NumAdditionalBuildUps();
		for(i=0)cond(i<iC)iter(i++)do
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(i))^.UpdateWeapon();
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(i))^.UpdateCaptainObj();
		endfor;

		ResetFlag();
		return bReturn;
	endproc;


	export proc void ProjectileOff()
		if(GetProjectile().IsEmpty())then return; endif;
		if(HasBuildUp())then
			var ^CGameObj pxObj = GetBuildUp()^.GetPrimaryLinkedObj().GetObj();
			if(pxObj==null)then return; endif;

			var CFourCC xLink = "psh1"; var vec3 vP;
			if(pxObj^.GetLinkPosObj(xLink, vP))then
				pxObj^.RemLinkGFX(xLink);
				return;
			endif;
		else
			super.ProjectileOff();
		endif;
	endproc;

	export proc vec3 GetProjectileStartPos(int p_iIdx)
		return super.GetProjectileStartPos(p_iIdx);
	endproc;

	export proc vec3 GetProjectileStartPos()

		var bool bBuildUpLink = false;

		if(!HasBuildUp())then return super.GetProjectileStartPos(); endif;

		var vec3 vBuildUpBasePos;
		var vec3 vProjectilePos;

		var CFourCC xProjectileLink = "Proj";
		var CFourCC xBuildUpLink = GetBuildUp()^.GetPrimaryLink();

		if(!GetLinkPosWorld(xBuildUpLink, vBuildUpBasePos))then return super.GetProjectileStartPos(); endif;

		var ^CGameObj pxObj = GetBuildUp()^.GetPrimaryLinkedObj().GetObj();
		if(pxObj==null)then return super.GetProjectileStartPos(); endif;

		if(!pxObj^.GetLinkPosWorld(xProjectileLink, vProjectilePos))then return super.GetProjectileStartPos(); endif;

		vProjectilePos = vProjectilePos-vBuildUpBasePos;

		var Quat qAdditionalRot = pxObj^.GetAdditionalRot();

		qAdditionalRot.VecRotateU(vProjectilePos);

		return (vBuildUpBasePos+vProjectilePos);

	endproc;


	proc void SetReleaseWhileDying()
		m_bReleaseWhileDying = true;
	endproc;

	proc bool IsReleaseWhileDying()
		return m_bReleaseWhileDying;
	endproc;

	export proc bool HasBuildUp()
		return m_iBuildUpType!=CBuildUpBase.TYPE_NONE;
	endproc;

	export proc bool HasBuildUp(int p_iType)
		return m_iBuildUpType==p_iType;
	endproc;

	export proc int NumAdditionalBuildUps()
		return m_aiAdditionalBuildUps.NumEntries();
	endproc;

	export proc bool HasAdditionalBuildUp(int p_iIndex)
		return m_aiAdditionalBuildUps.NumEntries()>p_iIndex && m_aiAdditionalBuildUps[p_iIndex]!=0;
	endproc;

	export proc void SetBuildUp(int p_iType)
		m_iBuildUpType = p_iType;
		m_pxBuildUp = CBuildUpFactory.Get().CreateBuildUp(m_iBuildUpType);
		m_pxBuildUp^.SetParent(GetHandle());
		ResetFlag();
	endproc;

	export proc void AddAdditionalBuildUp(int p_iType)
		m_aiAdditionalBuildUps.AddEntry(p_iType);
		SetAdditionalBuildUp(p_iType);
	endproc;


	export proc void SetAdditionalBuildUp(int p_iType)
		var ^CBuildUpBase pxBase = CBuildUpFactory.Get().CreateBuildUp(p_iType);
		m_apxAdditionalBuildUps.AddEntry(pxBase);
		pxBase^.SetParent(GetHandle());
		ResetFlag();
	endproc;


	export proc bool IsBuildUpBusy()
		return HasTimer(TIMER_BUILDUP_BUSY);
	endproc;


	export proc void SetBuildUpBusy(real p_fDuration)
		if(!IsBuildUpBusy())then
			CreateTimer(TIMER_BUILDUP_BUSY, CGameTimeSpan.OneSecond()*p_fDuration, false);
		endif;
	endproc;

	export proc void ResetFlag()
		m_sCurFlagDesc.Empty();
		CheckLevelFlag();
	endproc;


	export proc ^CBuildUpBase GetBuildUp()
		return m_pxBuildUp;
	endproc;

	export proc ^CBuildUpBase GetAdditionalBuildUp(int p_iIndex)
		if(HasAdditionalBuildUp(p_iIndex))then
			return m_apxAdditionalBuildUps[p_iIndex];
		endif;
		return null;
	endproc;


	export proc void CreateCaptain()

		if(m_sCaptainClass.IsEmpty())then
			if(m_xCaptain.IsValid()) then
				m_xCaptain.GetObj()^.Delete();
	 		endif;
			m_xCaptain.FromInt(-1);
			return;
		endif;

		if(!m_xCaptain.IsValid()) then
			var ^CCaptain pxC = cast<CCaptain>(CSrvWrap.GetObjMgr()^.CreateObj("universal_captain", GetOwner()));
			if(pxC!=null) then

				pxC^.Init(GetHandle());
				AddGroupedChildren(pxC^.GetGuid());

				m_xCaptain = pxC^.GetHandle();
			endif;
		endif;

		var ^CCaptain pxCaptain = cast<CCaptain>(m_xCaptain.GetObj());
		if(pxCaptain!=null)then
			pxCaptain^.UpdateGfx();
		endif;
		LinkCaptainObj();

	endproc;

	export proc void LinkCaptainObj()
		var ^CGameObj pxCaptain = m_xCaptain.GetObj();
		if(pxCaptain==null)then return; endif;

		AddGroupedChildren(pxCaptain^.GetGuid());
		var bool bBuildUpLink; var CFourCC xLink;
		if(GetCaptainLink(xLink, bBuildUpLink))then

			pxCaptain^.SetVisible(true);

			if(bBuildUpLink && HasBuildUp())then
				pxCaptain^.RideAction(GetBuildUp()^.GetPrimaryLinkedObj(),xLink,{0.0,0.0,0.0});
			else
				pxCaptain^.RideAction(GetHandle(),xLink,{0.0,0.0,0.0});
			endif;

			DoCaptainAnim();
			return;
		endif;
		xLink = "NONE";
		pxCaptain^.LinkAction(GetHandle(),xLink);
		pxCaptain^.SetVisible(false);
	endproc;

	//Overload when needed
	export proc bool GetCaptainLink(ref CFourCC po_rxLink, ref bool po_rbIsBuildUpLink)
		return false;
	endproc;

	export proc int NumPassengers()
		return (m_xPassengers.NumEntries() + m_xPotentialPassengers.NumEntries() + m_iBlockedSlots + m_iPotentiallyBlockedSlots);
	endproc;

	export proc int NumFreeSeats()
		return m_iMaxPassengers - NumPassengers();
	endproc;

	//called at the beginning of board-task, to stop passengers from trying to enter, when theres no space left
	export proc bool RegisterPassenger(CObjHndl p_xPassenger)
		if(!p_xPassenger.IsValid())then return false; endif;

		var int iNumPassengers = NumPassengers();

		if(iNumPassengers >= m_iMaxPassengers)then return false; endif;

		var int iNewPassengers = 1;
		var int iNewPasPassengers = 0;

		var ^CTransportObj pxTransportObj = cast<CTransportObj>(p_xPassenger.GetObj());
		if(pxTransportObj!=null)then
			iNewPasPassengers = pxTransportObj^.NumPassengers();
		endif;

		if((iNumPassengers+iNewPassengers+iNewPasPassengers) > m_iMaxPassengers)then return false; endif;

		m_xPotentialPassengers.Include(p_xPassenger);
		m_iPotentiallyBlockedSlots += iNewPasPassengers;
		UpdatePassengerAttribs();
		return true;
	endproc;

//	proc void LogAll(string p_sLog)
//		KLog.LogSpam("JaNe",GetName()+" "+p_sLog+" m_xPassengers = "+m_xPassengers.NumEntries().ToString());
//		KLog.LogSpam("JaNe",GetName()+" "+p_sLog+" m_xPotentialPassengers = "+m_xPotentialPassengers.NumEntries().ToString());
//		KLog.LogSpam("JaNe",GetName()+" "+p_sLog+" m_iBlockedSlots = "+m_iBlockedSlots.ToString());
//		KLog.LogSpam("JaNe",GetName()+" "+p_sLog+" m_iPotentiallyBlockedSlots = "+m_iPotentiallyBlockedSlots.ToString());
//	endproc;

	export proc void UnregisterPassenger(CObjHndl p_xPassenger)

		var bool bFound = m_xPotentialPassengers.FindEntry(p_xPassenger)!=-1;

		m_xPotentialPassengers.RemEntry(p_xPassenger);

		if(bFound)then
			var ^CTransportObj pxTransportObj = cast<CTransportObj>(p_xPassenger.GetObj());
			if(pxTransportObj!=null)then
				m_iPotentiallyBlockedSlots -= pxTransportObj^.NumPassengers();
			endif;
		endif;

		UpdatePassengerAttribs();

	endproc;


	export proc bool IsBuildUpAutoAttack()
		return GetTechTree().GetValueI(GetObjPath()+"/buildup_autoattack", 0)==1;
	endproc;


	export proc void Fight(^CGameObj p_pxTarget, vec3 p_vPos, bool p_bUserCommand)
		if (!IsAbleToFight()) then return; endif;

		var bool bOldUserCmd = false;
		var bool bNewUserCmd = p_bUserCommand;

		if(m_pxTaskMgr!=null)then
			if(m_pxTaskMgr^.GetCurTask()!=null)then
				bOldUserCmd = m_pxTaskMgr^.GetCurTask()^.IsUserCommand();
			endif;
		endif;

		if(!bNewUserCmd && bOldUserCmd)then
			return;
		endif;

		if(GetTransportObj().IsValid())then
			return;
		endif;

		if(HasBuildUp())then
			GetBuildUp()^.Fight(p_pxTarget, p_vPos, bNewUserCmd);
		endif;

		if(p_bUserCommand)then

			var int i, iC = NumAdditionalBuildUps();
			for(i=0)cond(i<iC)iter(i++)do
				GetAdditionalBuildUp(i)^.Fight(p_pxTarget, p_vPos, bNewUserCmd);
			endfor;

		endif;

		super.Fight(p_pxTarget, p_vPos, p_bUserCommand);

	endproc;


	export proc void SetAggressionState(int p_iState)
		super.SetAggressionState(p_iState);
		var int i, iC = m_xPassengers.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxFight = cast<CFightingObj>(m_xPassengers[i].GetObj());
			if(pxFight==null)then continue; endif;
			pxFight^.SetAggressionState(p_iState);
		endfor;

		if(HasBuildUp())then
			GetBuildUp()^.SetAggressionState(p_iState);
		endif;

		iC = NumAdditionalBuildUps();
		for(i=0)cond(i<iC)iter(i++)do
			GetAdditionalBuildUp(i)^.SetAggressionState(p_iState);
		endfor;
	endproc;


	export proc void DoCaptainAttackAnim()
		if(m_xCaptain.IsValid() && (HasBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN) && NumAdditionalBuildUps()<=0))then
			var ^CGameObj pxCaptain = m_xCaptain.GetObj();
			if(pxCaptain^.HasAnim(m_sCaptainAttackAnim))then
				pxCaptain^.SetAnim(m_sCaptainAttackAnim, 1);
			endif;
		endif;
	endproc;

	export proc void DoBuildUpCaptainAttackAnim()
		if(m_xCaptain.IsValid())then
			var ^CGameObj pxCaptain = m_xCaptain.GetObj();
			if(pxCaptain^.HasAnim(m_sCaptainAttackAnim))then
				pxCaptain^.SetAnim(m_sCaptainAttackAnim, 1);
			endif;
		endif;
	endproc;

	export proc void DoCaptainAnim()
		if(m_xCaptain.IsValid())then
			var ^CGameObj pxCaptain = m_xCaptain.GetObj();
			if(pxCaptain^.HasAnim(m_sCaptainAnim))then
				pxCaptain^.SetAnim(m_sCaptainAnim, 3);
			endif;
		endif;
	endproc;


	export proc void SwitchToAttackMode()
		if(GetCurrentAnimName()!="standanim" && HasAnim("standanim"))then
			SetAnim("standanim",3);
		endif;
	endproc;


	export proc void SwitchToWalkMode()
	endproc;


	export proc void SetOwner(int p_iOwner)
		super.SetOwner(p_iOwner);

		var CObjList xList=m_xPassengers;

		var int i, iC = xList.NumEntries();
		for(i=0)cond(i<iC)iter(++i)do
			var ^CGameObj pxO = xList[i].GetObj();
			if(pxO==null) then continue; endif;
			if(cast<CHero>(pxO)!=null || GetClassName()=="special_eusmilus")then
				OnDismount(xList[i]);
				continue;
			endif;
			pxO^.SetOwner(p_iOwner);
		endfor;

		if(HasBuildUp())then
			GetBuildUp()^.SetOwner(p_iOwner);
		endif;

		iC = NumAdditionalBuildUps();
		for(i=0)cond(i<iC)iter(i++)do
			GetAdditionalBuildUp(i)^.SetOwner(p_iOwner);
		endfor;
		// Henry: change captains owner too (color bug)
		var ^CCaptain pxCaptain = cast<CCaptain>(m_xCaptain.GetObj());
		if(pxCaptain!=null)then
			pxCaptain^.SetOwner(p_iOwner);
		endif;
	endproc;


	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)

		if(HasBuildUp())then
			var ^CBuildUpWeapon pxWeapon = cast<CBuildUpWeapon>(GetBuildUp());
			if(pxWeapon!=null)then
				if(GetRightHandWeapon()==GetCurrentWeapon())then
					if(pxWeapon^.AttackEnemy(p_pxEnemy, p_vTarget))then
						if(HasAnim("attack_front_secondary"))then
							SetAnim("attack_front_secondary",1);
						endif;
						return false;
					endif;
				endif;
			endif;
			if(GetCurTask()^.IsUserCommand())then
				if(HasBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN))then
					var int i,iC=m_xPassengers.NumEntries();
					for(i=0)cond(i<iC)iter(i++)do
						var ^CCharacter pxPassenger=cast<CCharacter>(m_xPassengers[i].GetObj());
						if(pxPassenger==null)then continue; endif;
						pxPassenger^.AttackTransportersTarget();
					endfor;
				endif;
				var int i, iC = NumAdditionalBuildUps();
				for(i=0)cond(i<iC)iter(i++)do
					GetAdditionalBuildUp(i)^.Fight(p_pxEnemy, p_vTarget, true);
				endfor;
			endif;
		endif;

		DoCaptainAttackAnim();
		return super.AttackEnemy(p_pxEnemy, p_vTarget, p_rbRotated);

	endproc;

	export proc bool IsFull()
		return (NumPassengers() >= m_iMaxPassengers);
	endproc;

	export proc bool IsFull(CObjHndl p_xPassenger)
		return (NumPassengers() >= m_iMaxPassengers) && m_xPotentialPassengers.FindEntry(p_xPassenger)==-1;
	endproc;

	// true if a valid point for dropping the passenger is near, po_rvDropPos contains one valid point afterwards or {0.0,0.0,0.0} if no one exists
	proc bool CanDropPassenger(CObjHndl p_xPassenger, ref vec3 po_rvDropPos)
		if (CanSwim() && IsInWater()) then
			return CanDropPassengerSwimmingUnit(p_xPassenger,po_rvDropPos);
		else
			return CanDropPassengerWalkingUnit(p_xPassenger,po_rvDropPos);
		endif;
	endproc;
	
	proc bool CanDropPassengerWalkingUnit(CObjHndl p_xPassenger, ref vec3 po_rvDropPos)
		var ^CFightingObj pxPassenger = cast<CFightingObj>(p_xPassenger.GetObj());
		if(pxPassenger!=null) then
			po_rvDropPos = GetPos();
			return CSrvWrap.GetPathfinder().IsFreePoint(GetPos(), true, false, GetOwner());
		endif;
		return false;
	endproc;

	proc bool CanDropPassengerSwimmingUnit(CObjHndl p_xPassenger, ref vec3 po_rvDropPos)
		var ^CFightingObj pxPassenger = cast<CFightingObj>(p_xPassenger.GetObj());
		if(pxPassenger!=null) then
			// Henry: units like baryonyx should the player be always able to unboard  from ships 
			if(pxPassenger^.CanSwim())then return true; endif;

			//var vec3 vLandingPos = GetNearestPosOnLand(po_rvDropPos,pxPassenger, m_fMaxPassengerDropRadius);
			var vec3 vLandingPos = po_rvDropPos;
			if(vLandingPos=={0.0f,0.0f,0.0f}) then vLandingPos=GetPos(); endif;

			//obsolete, handled within Die()-Methods of Ship and Vehicle
			// release units if ship is dying
			//if (vLandingPos != {0.0,0.0,0.0} && IsReleaseWhileDying()) then
			//	po_rvDropPos = vLandingPos;
			//	return true;
			//endif;

			//KLog.LogSpam("Unboard","CTransportObj::CanDropPassenger nearest pos "+vLandingPos.ToString()+" MaxDist "+m_fMaxPassengerDropRadius.ToString());
			if(vLandingPos=={0.0f,0.0f,0.0f}) then
				CFeedback.Print(GetOwner(), CFeedback.INFO, "_NT_TransportTooFarFromShore");
				po_rvDropPos = {0.0,0.0,0.0};
				return false;
			endif;

			// calc position where a virtual passenger at the nearest pos on land and the ship would meet if the passenger would like to board the ship
			var vec3 vVirtualMeetingPoint;
			var ^CPathfinder pxPF = ^(CSrvWrap.GetPathfinder());
			if(!pxPF^.GetShipBoardingPos(this^.GetOwner(),vLandingPos, this^.GetPos(), vVirtualMeetingPoint))then
				//KLog.LogSpam("Unboard", "CTransportObj::CanDropPassenger Can't find path");
				po_rvDropPos = {0.0,0.0,0.0};
				return false;
			endif;
			
			// calc the distance beetween the virtual meeting point and the current position
			// and evaluate the distance between them. if the distance is greater than the
			// given radius the free pos is too far away to unboard here
			//KLog.LogSpam("Unboard", "CTransportObj::CanDropPassenger Dist : "+(vVirtualMeetingPoint-this^.GetPos()).Abs2().ToString()+" MaxDist: "+m_fMaxPassengerDropRadius.ToString());
			if((vVirtualMeetingPoint-this^.GetPos()).Abs2()>m_fMaxPassengerDropRadius) then
				//CFeedback.Print(GetOwner(), CFeedback.INFO, "_NT_TransportUnboardAtShore");
				CFeedback.Print(GetOwner(), CFeedback.INFO, "_TransportObj_UnboardAtShore");
				po_rvDropPos = {0.0,0.0,0.0};
				return false;
			endif;

			po_rvDropPos = vVirtualMeetingPoint;
			return true;
		endif;
		return false;
	endproc;

	proc void PlacePassengerIntoWorld(CObjHndl p_xPassenger, vec3 p_vDropPosition)
		var ^CFightingObj pxPassenger = cast<CFightingObj>(p_xPassenger.GetObj());
		if(pxPassenger!=null) then
			pxPassenger^.GetWeaponMgr()^.SetAutoWeaponChange(true);
			pxPassenger^.TerminateAction();
			pxPassenger^.SetVisible(true);
			pxPassenger^.SetTransportObj(CObjHndl.Invalid());

			var vec3 vTmpDropPos;

			if (p_vDropPosition != {0.0,0.0,0.0}) then
			// external drop pos
				vTmpDropPos.SetX(p_vDropPosition.GetX());
				vTmpDropPos.SetY(p_vDropPosition.GetY());
				vTmpDropPos.SetZ(CSrvWrap.GetScapeMgr().GetHeight(p_vDropPosition.GetX(),p_vDropPosition.GetY()));
			else
			// auto drop pos
				CSrvWrap.GetObjMgr()^.GetFreePos(vTmpDropPos, pxPassenger, GetPos(), null, true, false, false, 10.0f, 010b);
				if (vTmpDropPos == {0.0,0.0,0.0}) then vTmpDropPos = GetPos(); endif;
			endif;

			// set passenger
			pxPassenger^.SetPos(vTmpDropPos);

			// auto spread
			var vec3 vSpreadPosition = GetRandomOffset(vTmpDropPos);
			pxPassenger^.GoTo(vSpreadPosition, true, pxPassenger^.GetMaxSpeed(), true, true);
			//KLog.LogSpam("Unboard","CTransportObj::PlacePassengerIntoWorld TransporterPos="+GetPos().ToString()+" DropPos="+vTmpDropPos.ToString()+" SpreadPos="+vSpreadPosition.ToString());
		endif;
	endproc;

	export proc bool OnDismount(CObjHndl p_xPassenger)
		return OnDismount(p_xPassenger,false,{0.0,0.0,0.0});
	endproc;

	///////
	//	OnDismount()
	//
	//	tells the passenger to get off the transport obj or anything that has to be done with the passenger,
	//	SetVisible() etc..
	//
	//	The unlinking and/or unhiding of the passenger is already done here
	//	In overloaded methods only the side effect, ex. disable RangeEffect, etc. must be enabled/disabled
	//  To check whether a passenger can dismount use an overwritten CanDropPassenger in your Subclass
	///////
	export proc bool OnDismount(CObjHndl p_xPassenger,bool p_bForceDismount, vec3 p_vDropPosition)
		//KLog.LogSpam("Unboard","CTransportObj::OnDismount");

		if(!p_xPassenger.IsValid())then return false; endif;
		if(m_xPassengers.FindEntry(p_xPassenger)==-1)then return false; endif;

		// NOTE if not p_bForceDismount -> calc new drop pos indirectly via CanDropPassenger
		var vec3 vTmpDropPos = p_vDropPosition;

		if (p_bForceDismount || CanDropPassenger(p_xPassenger,vTmpDropPos)) then
			if(HasBuildUp(CBuildUpBase.TYPE_TRANSPORTER) || HasBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN))then
				cast<CBuildUpTransporter>(GetBuildUp())^.RemovePassenger(p_xPassenger);
			elseif(HasBuildUp(CBuildUpBase.TYPE_WEAPON_TRANSPORTER))then
				cast<CBuildUpWeaponTransporter>(GetBuildUp())^.RemovePassenger(p_xPassenger);
			endif;

			m_xPassengers.RemEntry(p_xPassenger);

			PlacePassengerIntoWorld(p_xPassenger, vTmpDropPos);

			var ^CTransportObj pxTransporter = cast<CTransportObj>(p_xPassenger.GetObj());
			if(pxTransporter!=null)then
				m_iBlockedSlots -= pxTransporter^.NumPassengers();
			endif;

			if(HasBuildUp())then
				GetBuildUp()^.UpdateLinkedObjs();
			endif;

			UpdatePassengerAttribs();

			return true;
		endif;
		return false;
	endproc;


	///////
	//	OnMount()
	//
	//	tells the passenger to get on the transport obj or anything that has to be done with the passenger,
	//	SetVisible() etc..
	//	The linking and/or hiding is done already here. In overloaded methods only the side effects must be
	// 	enabled/disabled
	///////
	export proc bool OnMount(CObjHndl p_xPassenger)


		if(!p_xPassenger.IsValid())then return false; endif;

		if(m_xPassengers.FindEntry(p_xPassenger)!=-1)then return false; endif;

		var ^CFightingObj pxPassenger = cast<CFightingObj>(p_xPassenger.GetObj());
		if (pxPassenger==null) then return false; endif;

		if(GetTransportClass()!=2 && pxPassenger^.GetType()!="CHTR")then return false; endif;

		var ^CTransportObj pxTransporter = cast<CTransportObj>(pxPassenger);
		if (pxTransporter!=null && pxTransporter^.GetTransportClass()==2) then return false; endif;

		if(HasBuildUp(CBuildUpBase.TYPE_TRANSPORTER) || HasBuildUp(CBuildUpBase.TYPE_TRANSPORTER_OPEN))then
			cast<CBuildUpTransporter>(GetBuildUp())^.AddPassenger(p_xPassenger);
		elseif(HasBuildUp(CBuildUpBase.TYPE_WEAPON_TRANSPORTER))then
			cast<CBuildUpWeaponTransporter>(GetBuildUp())^.AddPassenger(p_xPassenger);
		endif;

		UnregisterPassenger(p_xPassenger);
		m_xPassengers.Include(p_xPassenger);

		pxPassenger^.GetWeaponMgr()^.SetAutoWeaponChange(true);

		if (pxTransporter!=null) then
			m_iBlockedSlots += pxTransporter^.NumPassengers();
		endif;

		CUniversalTriggerMgr.Get().OnTransportMount(GetHandle(),p_xPassenger);

		if(HasBuildUp())then
			GetBuildUp()^.UpdateLinkedObjs();
		endif;

		pxPassenger^.SetTransportObj(GetHandle());

		UpdatePassengerAttribs();
		return true;
	endproc;


	export proc void HandleAction(string p_sAction)
	endproc;

	export proc void SetTransportObj(CObjHndl p_xHndl)
		super.SetTransportObj(p_xHndl);
		if(!m_xTransportObj.IsValid())then
			if(HasBuildUp())then
				GetBuildUp()^.UpdateLinkedObjs();
			endif;
		endif;
	endproc;

	export proc int NeededSpaceInTransport()
		return m_xPassengers.NumEntries() + 1;
	endproc;

	export proc void DestroyBuildUp()

		if(HasBuildUp())then
			GetBuildUp()^.Kill();
		endif;
		m_iBuildUpType=CBuildUpBase.TYPE_NONE;
		m_pxBuildUp = null;

		var int i, iC = NumAdditionalBuildUps();
		for(i=0)cond(i<iC)iter(i++)do
			GetAdditionalBuildUp(i)^.Kill();
		endfor;
		m_aiAdditionalBuildUps = 0;
		m_apxAdditionalBuildUps = 0;

		LinkCaptainObj();

		SetTransportClass(0);

	endproc;


	export proc int GetMaxPassengers()
		return m_iMaxPassengers;
	endproc;


	export proc void SetMaxPassengers(int p_iNum)

		var int iOldPassengers = m_iMaxPassengers;

		if(iOldPassengers == p_iNum)then return; endif;

		m_iMaxPassengers = p_iNum;
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("max_passengers",m_iMaxPassengers);
		endif;

		if(iOldPassengers < p_iNum)then return; endif;

		var int iNewMax = p_iNum;

		while(m_xPassengers.NumEntries()>iNewMax)do
			if(!OnDismount(m_xPassengers[iNewMax]))then
				m_xPassengers.DeleteEntry(iNewMax);
			endif;
		endwhile;

	endproc;


	export proc string GetPassengerLoopAnim()
		return "standanim";
	endproc;


	export proc void PrepareUnboard(vec3 p_vPos)
		var ^CPrepareUnboard pxT = cast<CPrepareUnboard>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "PreUnbr"));
		if (pxT!=null) then
			pxT^.Init(GetHandle(), p_vPos);
			pxT^.SetUserCommand(true);
			m_pxTaskMgr^.SetTask(pxT);
		endif;
	endproc;

	export proc void Unboard(CObjHndl p_xPassenger)
		OnDismount(p_xPassenger);
	endproc;

	export proc bool DismountAll()
		return DismountAll({0.0,0.0,0.0});
	endproc;

	// units will placed into world and walk to p_vFinalDestination
	export proc bool DismountAll( vec3 p_vFinalDestination)
		var CObjList xPassengers=m_xPassengers;
		var int i,iC=xPassengers.NumEntries();
		var CObjList xWalkGroup;
		var vec3 vTmpDropPos = p_vFinalDestination;
		var CObjHndl xBiggest;
		for(i=0)cond(i<iC)iter(i++)do
			if(xPassengers[i].IsValid() && (!xBiggest.IsValid() || xPassengers[i].GetObj()^.GetCollisionRadius()>xBiggest.GetObj()^.GetCollisionRadius()))then
				xBiggest=xPassengers[i];
			endif;
		endfor;
		if(!CanDropPassenger(xBiggest,vTmpDropPos))then
			return false;
		endif;
		for(i=0)cond(i<iC)iter(i++)do
			xWalkGroup.AddEntry(xPassengers[i]);
			OnDismount(xPassengers[i],true,vTmpDropPos);
		endfor;
		if (p_vFinalDestination != {0.0,0.0,0.0}) then
			if ( (p_vFinalDestination - vTmpDropPos).Abs2() > m_fPassengerSpreadRadius ) then
				// start group walk
				CSrvWrap.GetObjMgr()^.HandleGPCmd("Action","/Walk",xWalkGroup,p_vFinalDestination);
			else
				// spread units
				for(i=0)cond(i<xWalkGroup.NumEntries())iter(i++)do
					if (xWalkGroup[i].IsValid()) then
						var ^CFightingObj pxFO = cast<CFightingObj>(xWalkGroup[i].GetObj());
						if (pxFO != null) then
							var vec3 vSpreadPosition = GetRandomOffset(vTmpDropPos);
							pxFO^.GoTo(vSpreadPosition, true, pxFO^.GetMaxSpeed(), true, true);
							//KLog.LogSpam("Unboard","CTransportObj::DismountAll TransporterPos="+GetPos().ToString()+" DropPos="+vTmpDropPos.ToString()+" SpreadPos="+vSpreadPosition.ToString());
						endif;
					endif;
				endfor;
			endif;
		endif;
		return true;
	endproc;

	///////
	//	GetPassengers()
	//
	//	returns all passengers as a CObjList
	///////
	export proc ref CObjList GetPassengers()
		return m_xPassengers;
	endproc;

	export proc void HandleEditorCommand(string p_sCommand,^CGameObj p_pxObject,vec3 p_vPos,string p_sMiscParams)
		if(p_sCommand=="LE_AddPassengers")then
			var array string asGuids;
			p_sMiscParams.Split(asGuids,"\n",true);
			var int i,iC=asGuids.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var CGuid xGuid;
				xGuid.FromString(asGuids[i]);
				var ^CGameObj pxObj = CSrvWrap.GetObjMgr()^.GetObjByGuid(xGuid);
				if (pxObj!=null) then
					OnMount(pxObj^.GetHandle());
				endif;
			endfor;
		elseif(p_sCommand=="LE_RemPassengers")then
			var array string asGuids;
			p_sMiscParams.Split(asGuids,"\n",true);
			var int i,iC=asGuids.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var CGuid xGuid;
				xGuid.FromString(asGuids[i]);
				var ^CGameObj pxObj = CSrvWrap.GetObjMgr()^.GetObjByGuid(xGuid);
				if (pxObj!=null) then
					OnDismount(pxObj^.GetHandle());
				endif;
			endfor;
		else
			super.HandleEditorCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams);
		endif;
	endproc;

	///////
	//	HandleGamePlayCommand()
	///////
	export proc void HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
		if (p_sCommand=="Harvest") then
			HarvestTask(p_pxObject, p_vPos);
		elseif (p_sCommand=="Mine") then
			MineTask(p_pxObject, p_vPos);
		elseif (p_sCommand=="GetFood") then
			GetFoodTask(p_pxObject, p_vPos);
		elseif(p_sCommand=="Action")then
        	if(p_sMiscParams.Find("/DismountAll") != -1)then
        		DismountAll();
			elseif(p_sMiscParams.Find("/Dismount")!=-1)then
				if(p_pxObject!=null)then
					//RT#15443
					//OnDismount(p_pxObject^.GetHandle());
					Unboard(p_pxObject^.GetHandle());
				endif;
			elseif(p_sMiscParams.Find("/PrepareUnboard")!=-1)then
				PrepareUnboard(p_vPos);
			elseif(p_sMiscParams.Find("/AddPassenger")!=-1)then
				if(p_pxObject!=null)then
					OnMount(p_pxObject^.GetHandle());
				endif;
			else
				super.HandleGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams);
			endif;
		else
			super.HandleGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams);
		endif;
	endproc;


	export proc void CheckLevelFlag()

		var int iLevel=GetLevel();
		var string sTribe=GetPlayerTribeName();
		var string sFlagGFX=sTribe+"_animal_flag_0"+(iLevel+1).ToString();
		var string sFlagDesc=sFlagGFX+"_"+m_iBuildUpType.ToString();

		//redundancy check
		if(m_sCurFlagDesc==sFlagDesc) then return; endif;

		if(!CSrvWrap.GetGfxMgrBase().FindGraphicSetEntry(sFlagGFX)) then return; endif;

		m_sCurFlagDesc=sFlagDesc;

		var CFourCC xFlag="flag";
		if(HasBuildUp())then
			var ^CGameObj pxLinkedObj = GetBuildUp()^.GetPrimaryLinkedObj().GetObj();
			if(pxLinkedObj!=null && pxLinkedObj^.HasLink(xFlag))then
				if(HasLink(xFlag)) then RemLinkGFX(xFlag); endif;
				pxLinkedObj^.SetLinkGFX(xFlag,sFlagGFX);
				return;
			endif;
		endif;

		if(HasLink(xFlag)) then
			SetLinkGFX(xFlag,sFlagGFX);
		endif;

	endproc;

	///////
	//	UpdatePassengerAttribs()
	//
	//	reads m_xPassengers and m_xCaptain and writes it to attribs
	///////
	proc void UpdatePassengerAttribs()

		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then

			var bool bHasValidCaptain = false;
			var int i;
			var string sPassengerAttrib;

			var int iNumPas=0;

			for(i=0)cond(i<m_xPassengers.NumEntries())iter(i++)do
				var ^CFightingObj pxPassenger=cast<CFightingObj>(m_xPassengers[i].GetObj());
				if(pxPassenger==null)then
					m_xPassengers.DeleteEntry(i);
					i--;
					continue;
				endif;
				iNumPas++;
				sPassengerAttrib += pxPassenger^.GetGuid().ToString()+"\n";
				var ^CTransportObj pxTransportPassenger=cast<CTransportObj>(pxPassenger);
				if(pxTransportPassenger!=null)then
					iNumPas+=pxTransportPassenger^.NumPassengers();
				endif;
			endfor;

			var int iCheckSum=(m_xPassengers.NumEntries()+m_xPotentialPassengers.NumEntries()+m_iBlockedSlots+m_iPotentiallyBlockedSlots);
			var int iOnBoard=m_xPassengers.NumEntries()+m_iBlockedSlots;

			pxAttr^.SetValue("passenger_guids", sPassengerAttrib);
			pxAttr^.SetValue("passengers_onboard",iOnBoard);
			pxAttr^.SetValue("registered_passengers",iCheckSum);
		endif;

	endproc;


	export proc bool UpdateGfx()
		var bool bRes=super.UpdateGfx();
		var ^CCaptain pxCaptain = cast<CCaptain>(m_xCaptain.GetObj());
		if(pxCaptain!=null)then
			pxCaptain^.UpdateGfx();
		endif;
		DoCaptainAnim();
		var int i, iC = NumAdditionalBuildUps();
		for(i=0)cond(i<iC)iter(i++)do
			cast<CBuildUpWeapon>(GetAdditionalBuildUp(i))^.UpdateCaptainObj();
		endfor;
		return bRes;
	endproc;


	export proc void OnTechTreeChange()
		super.OnTechTreeChange();

		var CStringArray asArray;
		asArray.AddEntry(GetObjPath()+"/captainclass");
		OnTechTreeChange(asArray);
	endproc;


	///////
	//	OnTechTreeChange()
	///////
	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
		super.OnTechTreeChange(p_rasChanges);

		var bool bCptChg = false;
		var int i,iC = p_rasChanges.NumEntries();
		var string sObjPath="/"+GetObjPath();

		m_iNeededLevel = m_xTechTree.GetValueI(GetObjPath()+"/captainlevel",1)-1;

		for(i=0)cond(i<iC)iter(i++)do
			var string sVal = p_rasChanges[i];
			if(sVal.Find("captainclass")>=0)then
				UpdateCaptainClass();
			elseif(sVal.Find("/flags")!=-1&&((sVal.Find(sObjPath)!=-1)||(sObjPath.Find(sVal)!=-1))) then
				var ^CTechTree.CNode pxFlags=m_xTechTree.FindNode(GetObjPath()+"/flags");
				if(pxFlags!=null)then
					var int i,iC=pxFlags^.NumSubs();
					for(i=0)cond(i<iC)iter(i++)do
						var string sFlag=pxFlags^.GetSub(i)^.GetName();
						if(sVal.Right(sFlag.GetLength())==sFlag) then
							HandleAction(sFlag);
						endif;
					endfor;
				endif;
			endif;
		endfor;

		UpdateMaxPassengers();

	endproc;

	export proc void UpdateMaxPassengers()
		SetMaxPassengers(m_xTechTree.GetValueI(GetObjPath()+"/max_passengers", 0));
	endproc;

	export proc void UpdateCaptainClass()
		var string sNewClass = m_xTechTree.GetValueS(GetObjPath()+"/captainclass", "");
		if(m_sCaptainClass != sNewClass)then
			m_sCaptainClass = sNewClass;
			CreateCaptain();
		endif;
	endproc;


	export proc string GetCaptainClass()
		return m_sCaptainClass;
	endproc;

//	proc vec3 GetNearestPosOnLand(vec3 p_vPos,^CFightingObj p_pxPassenger, real p_fMaxDist)
//		var vec3 vPos = p_vPos;
//		if(vPos=={0.0f,0.0f,0.0f}) then vPos=GetPos(); endif;
//		if(!CSrvWrap.GetObjMgr()^.GetFreePos(vPos,p_pxPassenger,vPos,null,false,false,true,1.0f,CObjMgrHost.GFPLT_Land)) then
//			vPos={0.0f,0.0f,0.0f};
//			return vPos;
//		endif;
//		//KLog.LogSpam("Unboard", "TransportObj::GetNearestPosOnLand "+(vPos-GetPos()).Abs2().ToString());
//		if((vPos-GetPos()).Abs2()>p_fMaxDist) then
//			vPos={0.0f, 0.0f, 0.0f};
//		endif;
//		return vPos;
//	endproc;

	proc vec3 GetRandomOffset(vec3 p_vLandPos)
		//KLog.LogSpam("Unboard","CTransportObj::GetRandomOffset");
		var real fSea = CSrvWrap.GetScapeMgr().GetSeaLevel();
		var real fZ = 0.0f;
		var real fX,fY;

		var int iSafeCounter = 50;
		while ( (fZ <= fSea+1.0f) && (--iSafeCounter>0)) do
			fX = p_vLandPos.GetX() + Random.MTRandF(-7.0f, 7.0f);
			fY = p_vLandPos.GetY() + Random.MTRandF(-7.0f, 7.0f);
			fZ = CSrvWrap.GetScapeMgr().GetHeight(fX,fY);
		endwhile;

		if (iSafeCounter==0) then
			return p_vLandPos;	 //this is the best we have...
		else
			var vec3 vRet;
			vRet.SetXYZ(fX,fY,fZ);
			return vRet;
		endif;
	endproc;

	export proc void SetCaptainAnim(string p_sAnim)
		if(m_sCaptainAnim!=p_sAnim)then
			m_sCaptainAnim = p_sAnim;
		endif;
	endproc;


	export proc void SetCaptainAttackAnim(string p_sAnim)
		if(m_sCaptainAttackAnim!=p_sAnim)then
			m_sCaptainAttackAnim = p_sAnim;
		endif;
	endproc;


	export proc string GetCaptainAnim()
		return m_sCaptainAnim;
	endproc;


	export proc string GetCaptainAttackAnim()
		return m_sCaptainAttackAnim;
	endproc;


	export proc void Die()

		while(m_xPassengers.NumEntries()>0)do
			if(!OnDismount(m_xPassengers[0]))then
				m_xPassengers.DeleteEntry(0);
			endif;
		endwhile;

		if(m_xCaptain.IsValid()) then
			m_xCaptain.GetObj()^.Delete();
		endif;

		super.Die();

	endproc;

	export proc void DieFastAndSilent()
		if(GetTransportObj().IsValid())then
			while(m_xPassengers.NumEntries()>0)do
				var ^CFightingObj pxPassenger = cast<CFightingObj>(m_xPassengers[0].GetObj());
				m_xPassengers.DeleteEntry(0);
				if(pxPassenger!=null)then
					pxPassenger^.TerminateAction();
					pxPassenger^.SetVisible(false);
					pxPassenger^.DieFastAndSilent();
				endif;
			endwhile;
		endif;
		super.DieFastAndSilent();
	endproc;

endclass;

class CTradeTransporter inherit CTransportObj

	var CObjHndl m_xHome;

	export constructor()
	endconstructor;

	export destructor()
	enddestructor;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xTrTr="TrTr"; //TradeTransporter
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xTrTr,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xHome.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="TrTr")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			//var int iVer=p_pxReaderNode^.GetVersion();
			m_xHome.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc void OnTechTreeChange()
		super.OnTechTreeChange();
	endproc;

	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
		super.OnTechTreeChange(p_rasChanges);
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null && pxAttr^.GetValueInt("trade")!=1)then
			pxAttr^.SetValue("trade",1);
		endif;
	endproc;

	export proc bool IsAbleToFight()
		return false;
	endproc;

	export proc void SetHome(CObjHndl p_xHome)
		m_xHome=p_xHome;
		var ^CAttribs pxAttribs = GetAttribs();
		if(pxAttribs!=null && m_xHome.GetObj()!=null)then
			pxAttribs^.SetValue("trade_home", m_xHome.GetObj()^.GetGuid().ToString());
		endif;
	endproc;

	export proc CObjHndl GetHome()
		if(!m_xHome.IsValid())then
			var ^CAttribs pxAttribs = GetAttribs();

			m_xHome = CObjHndl.Invalid();
			if(pxAttribs!=null)then pxAttribs^.SetValue("trade_home","0"); endif;

			var CObjQuery xQuery;
			xQuery.SetOwner(GetOwner());

			xQuery.SetAttribsPos("TradeBuilding",1);
			xQuery.SetAttribsNeg("CurTask","BuildUpB");
			var CObjList xList;
			if(xQuery.Execute(xList))then
				var int iIndex = xList.FindNearest(GetPos());
				if(iIndex!=-1)then
					SetHome(xList[iIndex]);
				endif;
			endif;
		endif;
		return m_xHome;
	endproc;

	export proc void Trade(^CGameObj p_pxTarget, bool p_bUserCommand)
		if(IsAbleToWalk())then

			var ^CTask pxOldTask = m_pxTaskMgr^.GetCurTask();
			var bool bOldUserCommand = false;

			if(pxOldTask!=null)then
				bOldUserCommand = pxOldTask^.IsUserCommand();
			endif;

			if(bOldUserCommand && !p_bUserCommand)then return; endif;

			if(p_pxTarget==null)then return; endif;
			var ^CAttribs pxAttr=p_pxTarget^.GetAttribs();
			if(pxAttr==null)then return; endif;
			if(!pxAttr^.ContainsKey("TradeBuilding") || pxAttr^.GetValueInt("TradeBuilding")!=1)then
				GoTo(p_pxTarget^.GetPos(), true, GetDefaultSpeed(), true, true);
			endif;

			if(!CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), p_pxTarget^.GetOwner()))then
				GoTo(p_pxTarget^.GetPos(), true, GetDefaultSpeed(), true, true);
			endif;

			var ^CTrade pxTask=cast<CTrade>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Trade"));

	    	pxTask^.Init(GetHandle(),p_pxTarget^.GetHandle());
	    	pxTask^.SetUserCommand(p_bUserCommand);
	    	m_pxTaskMgr^.SetTask(pxTask);

		endif;
	endproc;

	export proc void HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
		if(p_sCommand=="Dock")then
			if(p_pxObject!=null)then
				if(p_pxObject^.GetHandle()==GetHome())then
					GoTo(p_pxObject^.GetPos(), true, GetMaxSpeed(), true, true);
				else
					Trade(p_pxObject,true);
				endif;
			endif;
		else
			super.HandleGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams);
		endif;
    endproc;

	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()=="CTheLite")then
			m_xHome =  p_rxEvtPtr.GetObjHandle(0);

			var ^CAttribs pxAttribs = GetAttribs();
			if(pxAttribs!=null && m_xHome.GetObj()!=null)then
				pxAttribs^.SetValue("trade_home", m_xHome.GetObj()^.GetGuid().ToString());
			endif;

			super.HandleEvent(p_rxEvtPtr);
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;

endclass;


class CCaptain inherit CTaskBuildUp

	var string			m_sCaptainClass;
	var CObjHndl		m_xParent;


	export proc void Init(CObjHndl p_xParent)
		m_xParent = p_xParent;
		UpdateGfx();
	endproc;

	export proc void OnPostLoad()
		super.OnPostLoad();
		if(m_xParent.GetObj()==null)then
			Delete();
		endif;
		var ^CTransportObj pxParent = cast<CTransportObj>(m_xParent.GetObj());
		if(pxParent!=null)then
			pxParent^.StopBuildUpFighting();
		endif;
/*		var ^CBuildUpFight pxFight = cast<CBuildUpFight>(GetCurTask());
		if(pxFight!=null)then
			var ^CFSM pxFSM = GetFSM();
			if(pxFSM!=null)then
				pxFSM^.Enable(true);
			endif;
		endif;
*/	endproc;

	export proc bool UpdateGfx()
		var ^CTransportObj pxParent = cast<CTransportObj>(m_xParent.GetObj());
		if(pxParent==null)then
			Delete();
			return false;
		endif;

		var string sCaptainClass=pxParent^.GetCaptainClass();
		if(sCaptainClass.IsEmpty()) then
			//ERROR
			KLog.LogWarn("TransportObj","Missing Captainclass: "+pxParent^.GetName());
			return false;
		endif;

		var int iLevel = pxParent^.GetLevel();
		var string sCaptainPath = "Objects/"+pxParent^.GetTribeName()+"/CHTR/"+sCaptainClass;
		var CTechTree xTechTree = pxParent^.GetTechTree();

		var ^CTechTree.CNode pxCaptainNode = xTechTree.FindNode(sCaptainPath);
		if(pxCaptainNode==null)then
			KLog.LogWarn("TransportObj","Captainclass: '"+sCaptainClass+"' not found in TechTree!");
			Delete();
			return false;
		endif;

		var string sOriginalGfx = pxCaptainNode^.GetSubValue("gfx");
		var string sLevelGfx = sOriginalGfx;
		begin LevelGfx;
			sLevelGfx.Delete(sOriginalGfx.GetLength()-1);
			if(sLevelGfx=="Stina_s")then
				sLevelGfx += iLevel.ToString();
			else
				sLevelGfx += (iLevel+1).ToString();
			endif;
		end LevelGfx;

		if(!CSrvWrap.GetGfxMgrBase().FindGraphicSetEntry(sLevelGfx))then
			sLevelGfx = sOriginalGfx;
		endif;

		if(sLevelGfx != GetGfxName())then
			SetGFX(sLevelGfx);
		endif;

		var array CCharacter.CWeaponGfx axWeapons;

		var string sWeaponPath = "Objects/"+pxParent^.GetTribeName()+"/Weapons/";
		var ^CTechTree.CNode pxWeapons = xTechTree.FindNode(sWeaponPath);
		var int iMinLevel = -1;
		var int iMaxLevel = iLevel+1;
		if(pxWeapons!=null)then
			var int i, iC = pxWeapons^.NumSubs();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CTechTree.CNode pxWeapon = pxWeapons^.GetSub(i);
				if(pxWeapon==null)then continue; endif;
				var ^CTechTree.CNode pxUsers = pxWeapon^.GetSub("Users");
				if(pxUsers==null)then continue; endif;
				var bool bFound = false;
				var int iA, iAC = pxUsers^.NumSubs();
				for(iA=0)cond(iA<iAC)iter(iA++)do
					var string sUser = pxUsers^.GetSubValue(iA.ToString());
					if(sUser==sCaptainClass)then
						bFound = true;
						break;
					endif;
				endfor;
				if(!bFound)then continue; endif;
				var int iLvl = pxWeapon^.GetSubValueI("level");
				if(iLvl<=iMinLevel || iLvl>iMaxLevel)then continue; endif;
				if(pxWeapon^.GetSubValueI("secondary")!=0) then continue; endif;
				axWeapons = 0;
				var ^CTechTree.CNode pxParts = pxWeapon^.GetSub("Parts");
				if(pxParts==null)then continue; endif;
				iAC = pxParts^.NumSubs();
				for(iA=0)cond(iA<iAC)iter(iA++)do
					var ^CTechTree.CNode pxPart = pxParts^.GetSub(iA);
					if(pxPart==null)then continue; endif;
					var CFourCC xLink = pxPart^.GetSubValue("Links");
					var ^CTechTree.CNode pxN = pxPart^.GetSub("Gfx");
					if(pxN==null)then continue; endif;
					var string sGFX = pxN^.GetSubValue(0);
					if(sGFX.IsEmpty())then continue; endif;
					var ^CCharacter.CWeaponGfx pxGfx = ^(axWeapons.NewEntryRef());
					var string sGFXName=CSrvWrap.GetObjMgr()^.GetClassGFXName(sGFX);
					pxGfx^.m_xLink = xLink;
					pxGfx^.m_sGfx = sGFXName;
				endfor;
			endfor;

			RemAllLinkGFX();

			iC = axWeapons.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CCharacter.CWeaponGfx pxGfx = ^(axWeapons[i]);
				if(pxGfx^.IsValid())then
					SetLinkGFX(pxGfx^.m_xLink,pxGfx^.m_sGfx);
				endif;
			endfor;

		endif;

		return true;
	endproc;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="Capt"; //Captain
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xParent.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Capt")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVer=p_pxReaderNode^.GetVersion();
			if(iVer>=1)then
				m_xParent.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;


endclass;

class CTaskHook inherit CTaskChangeSubscriber
	var ^CTransportObj m_pxTO;

	export constructor(^CTransportObj p_pxTO);
		m_pxTO = p_pxTO;
	endconstructor;

	export destructor();
	enddestructor;

	export proc bool OnPush(string p_sFrom, string p_sTo)
		return false;
	endproc;
endclass;


class CTmpLinkSlot
	export proc void DoKArc(ref CArc p_rxArc)
		var CFourCC xLink; var CObjHndl xInvalid; var string sInvalid;
		p_rxArc << sInvalid;
		xInvalid.DoKArc(p_rxArc);
		xInvalid.DoKArc(p_rxArc);
		p_rxArc << sInvalid;
	endproc;
endclass;
