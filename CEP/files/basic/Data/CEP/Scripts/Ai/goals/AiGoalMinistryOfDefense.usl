///CAiGoalMinistryOfDefense
class CAiGoalMinistryOfDefense inherit CAiGoal

	class CUnitsDescriptor
		export var array string	m_asClasses;
		export var array int	m_aiUnitCounts;
		export var array real	m_afWeights;
		export var int			m_iAllUnitCount;
		export var int			m_iLevel;
		
		export proc void Init()
			m_asClasses		= 0;
			m_aiUnitCounts	= 0;
			m_afWeights		= 0;
			m_iAllUnitCount = 0;
			m_iLevel		= 0;
		endproc;
	endclass;

	class CObjSorter
		export var real				m_fEffectiveness;
		export var CAiObjWrap		m_xObj;

		//op_Greater
		export proc bool op_Greater(ref CAiGoalMinistryOfDefense.CObjSorter p_rxOther)
			return (m_fEffectiveness < p_rxOther.m_fEffectiveness);
		endproc;
	endclass;	

	var CAiTaskBuildSquad	m_xAllocator;
	var CAiSolution			m_xSolution;
	var CAiNeedPtr			m_pxUnitNeed;
	var CPropDB				m_xUnitDB;
	var int					m_iTargetIdx;
	var int					m_iCurChkLevel;
	var int					m_iCurrentDefensePool;
	var array int 			m_aiReservedLevelSlots;
	static var CPropDB		ms_xCompareDB;
	var ^CAiBrain 			m_pxBrain;
	var ^CAiSensor			m_pxSensor;
	var string				m_sPlayerID;
	var int					m_iPlayerID;
	var string				m_sBehavior;
	var string				m_sGametype;
	var int					m_iRefreshCounter;
	var bool				m_bDefending;
	var bool				m_bRefreshUnits;
	var bool				m_bNow;
	var int					m_iAge;

	///constructor
	export constructor()
		m_aiReservedLevelSlots = 5;
		m_pxUnitNeed=CAiNeed.Create();
	endconstructor;
	
	
	///destructor
	export destructor()
	enddestructor;
	
		
	///init
	export proc bool Init(^CAiBrain p_pxBrain)
		super.Init(p_pxBrain);
		
		m_pxBrain = p_pxBrain;
		if(m_pxBrain==null)then return false; endif;
		
		m_pxSensor=^(m_pxBrain^.GetSensor());
		if(m_pxSensor==null) then return false; endif;
		
		m_iPlayerID=m_pxBrain^.GetPlayerId();
		m_sPlayerID=m_iPlayerID.ToString();
		m_sGametype=CAiUtilityMgr.Get()^.GetGameType(m_pxBrain);
		
		var int iNumPlayers=1+m_pxSensor^.GetNumPlayers();
		var int iType = 1+Random.GetInt()%iNumPlayers;
		
		SetThinkWait(5+iType);
		
		var ^CAiModuleControlDefault pxCM=cast<CAiModuleControlDefault>(m_pxBrain^.GetControlModule());
		m_sBehavior=pxCM^.GetBehaviorType();

		m_xAllocator.Init(this,false,false);
		m_xAllocator.SetPriority(100.0f);
		RemoveTask(^m_xAllocator);
		AddTask(^m_xAllocator);
		
		var ^CAiTechTree pxTT = GetAiTechTree();
		if(pxTT == null)then return false; endif;
		var string sTribe;
		sTribe = pxTT^.GetTribe();
	
		var string			sPath;
		sPath = m_pxSensor^.GetUrsRelPath() + "/Data/Base/Scripts/Ai/settings/" + sTribe + "/Units.txt";
		
		m_xUnitDB.Load(sPath);
		m_pxUnitNeed.GetNeed()^.Clear();
		m_pxUnitNeed.GetNeed()^.SetNeededInstanceCount(1);
		m_pxUnitNeed.GetNeed()^.SetGlobal(false);
		m_pxUnitNeed.GetNeed()^.SetLockable(true);
		m_iTargetIdx = 0;
		m_iCurChkLevel = -1;
		m_iCurrentDefensePool = 0;
		m_iRefreshCounter=0;
		m_bDefending=false;
		m_bNow=false;
		
		if(ms_xCompareDB.GetRoot().NumSubs()<=0)then		
			if(ms_xCompareDB.Load(m_pxSensor^.GetUrsRelPath()+"/Data/Base/Scripts/Ai/settings/CompareValue.txt") == false)then
				KLog.LogWarn("AiGoalMinistryOfDefense","Failed to load compare table: ../Data/Base/Scripts/Ai/settings/CompareValue.txt! PlayerID: "+m_sPlayerID);
			endif;
		endif;
		
		SetHighDefenseMode(false);
		return true;
	endproc;
	
	
	///SetHighDefenseMode
	export proc void SetHighDefenseMode(bool p_bHiDefMode)
		if(p_bHiDefMode == true)then
			var int i, iC = m_aiReservedLevelSlots.NumEntries();			
			for(i=0)cond(i<iC)iter(++i)do
				m_aiReservedLevelSlots[i] = 0;
			endfor;
		else
			m_aiReservedLevelSlots[0] = 6;
			m_aiReservedLevelSlots[1] = 5;
			m_aiReservedLevelSlots[2] = 3;
			m_aiReservedLevelSlots[3] = 1;
			m_aiReservedLevelSlots[4] = 0;
		endif;
	endproc;


	///Shut
	export proc void Shut()
		m_xAllocator.Shut();
		RemoveTask(^m_xAllocator);
	endproc;
	
	
	///ScheduleRefreshUnits
	export proc void ScheduleRefreshUnits()
		m_bRefreshUnits=true;
	endproc;
	

	//RefreshUnits
	proc void RefreshUnits()
		m_bRefreshUnits=false;
		var CAiObjQuery		xOQ;
		var CAiObjWrapList	xList;
		
		xList.Clear();
	
		xOQ.SetOwner(m_iPlayerID);
		xOQ.SetType("ANML");
		xOQ.SetType("CHTR", true);
		xOQ.SetType("VHCL", true);
		xOQ.Execute(xList);
		
		var ^CAiAllocationMgr pxAllocMgr = GetAiAllocationMgr();
		if(pxAllocMgr == null)then return; endif;

		var int i, iC = xList.Validate();
		for(i=0)cond(i<iC)iter(++i)do
			if(!IsAllowedUnit(xList[i]))then
				xList.DeleteEntry(i);
				i--;iC--;
				continue;
			elseif((pxAllocMgr^.IsUnitLocked(xList[i], true, true, true))||(xList[i].GetName().Find("_bunkercrew")!=(-1)))then				
				xList.DeleteEntry(i);
				i--;iC--;
				continue;
			endif;
		endfor;
		AddUnitsToPool(xList);
	endproc;
	
	
	///OnUnitAdded
	export proc void OnUnitAdded(ref CAiObjWrap p_rxOW, ^CAiNodeInstance p_pxNI)
	endproc;
	
	
	///NumUnits
	export proc int NumUnits()
		if(m_pxBrain==null) then return 0; endif;
		
		var ^CAiModuleDefenseDefault	pxDM;		
		pxDM = cast<CAiModuleDefenseDefault>(m_pxBrain^.GetDefenseModule());
		if(pxDM == null)then return 0; endif;
		
		return pxDM^.m_pxGoalGuardVillage^.GetUnitSupervisor().GetUnits().NumEntries();
	endproc;
	
	
	///Defending
	export proc void SetDefending(bool p_bDefending)
		m_bDefending=p_bDefending;
	endproc;
	
	
	///Defending
	export proc bool IsDefending()
		return m_bDefending;
	endproc;
	
	
	///ComputeCurrentAgeClasses
	export proc void ComputeCurrentAgeClasses(ref CAiGoalMinistryOfDefense.CUnitsDescriptor p_rxUnitDesc, int p_iLevel)
		if(m_pxBrain==null) then return; endif;
		if(m_pxSensor==null) then return; endif;
		
		var string			sAgePath	= "Age_"+m_iAge.ToString();
		var ^CPropDB.CNode	pxAgeNode;
		var ^CAiTechTree	pxTT		= GetAiTechTree();
		var array string	asAvailableNPCs;

		p_rxUnitDesc.Init();
		p_rxUnitDesc.m_iLevel = p_iLevel;
		if(pxTT == null)then return; endif;
		
		pxAgeNode = ^(m_xUnitDB[sAgePath]);
		if(pxAgeNode == null)then return; endif;
		
		GetAvailableNPCs(asAvailableNPCs);
		
		var string			sLevelPath = "Level_";
		var ^CPropDB.CNode	pxLevelNode;
		
		pxLevelNode = ^(m_xUnitDB[sAgePath+"/"+sLevelPath+(p_iLevel+1).ToString()]);
		if(pxLevelNode == null)then return; endif;
		
		var int	i, iC = pxLevelNode^.NumSubs();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CPropDB.CNode		pxGroupNode			= ^((pxLevelNode^)[i]);
			var int					iUnitSub, iUSubC	= pxGroupNode^.NumSubs();
			var int					iUC					= 0;
			var string				sClass				= "";
			
			for(iUnitSub=0)cond(iUnitSub<iUSubC)iter(iUnitSub++)do
				var ^CPropDB.CNode		pxUnitNode		= ^((pxGroupNode^)[iUnitSub]);
				var ^CPropDB.CNode		pxObjFlagNode	= pxUnitNode^.Get("ObjFlag");
				var string				sObjFlag;
				var CAiAttribs			xAttribs;
				
				if(pxObjFlagNode != null)then
					sObjFlag = pxObjFlagNode^.Value();
					if(sObjFlag.IsEmpty() == false)then
						xAttribs.SetValue("ObjFlag", sObjFlag);
					endif;
				endif;
				
				xAttribs.SetValue("level", p_iLevel.ToString());
				iUC += ComputeUnitCount(pxUnitNode^.Name(), xAttribs, p_iLevel);
				
				if((asAvailableNPCs.FindEntry(pxUnitNode^.Value()) == -1) && (pxUnitNode^.Value().IsEmpty() == false))then
					continue;
				endif;
				
				sClass = pxUnitNode^.Name();
			endfor;
			
			if(sClass.IsEmpty() == true)then
				continue;
			endif;
			
			p_rxUnitDesc.m_iAllUnitCount += iUC;
			p_rxUnitDesc.m_afWeights.AddEntry(pxGroupNode^.Value().ToReal());
			p_rxUnitDesc.m_asClasses.AddEntry(sClass);
			p_rxUnitDesc.m_aiUnitCounts.AddEntry(iUC);
		endfor;
	endproc;


	///GetNextBadUnit
	export proc bool GetNextBadUnit(ref CAiObjWrap p_rxOW, ^CAiObjWrapList p_pxUnitPool)
		if(p_pxUnitPool == null)then return false; endif;		
		if(p_pxUnitPool^.NumEntries() <= 0)then return false; endif;		
		p_rxOW = p_pxUnitPool^[0];
		return true;
	endproc;
	

	///ComputeMostEfficientUnitForTarget
	export proc bool ComputeMostEfficientUnitForTarget(ref CAiObjWrap p_rxOW, ^CAiObjWrapList p_pxUnitPool, CAiObjWrap p_xTarget)		
		var ^CAiTechTree pxTT = GetAiTechTree();
		if(pxTT == null)then return false; endif;		
		if(p_pxUnitPool == null)then return false; endif;		
		if(p_xTarget.IsValid() == false)then return false; endif;
		
		var int					i, iC	= p_pxUnitPool^.NumEntries();
		var ^CPropDB.CNode		pxType	= ms_xCompareDB.GetRoot().Get(p_xTarget.GetType().AsString());
		var array CObjSorter 	axObjects;
		var ^CAiNodeInstance	pxTargetNI;

		if(pxType==null)then return false; endif;
		
		pxTargetNI = pxTT^.FindNodeInstance(p_xTarget);
		if(pxTargetNI == null)then return false; endif;
		
		for(i=0)cond(i<iC)iter(i++)do
			var string				sObjClass					= p_pxUnitPool^[i].GetClassName();
			var string				sObjObjFlag					= p_pxUnitPool^[i].GetAttribValue("ObjFlag");
			var bool				bFoundInTable				= false;
			var int					iTableEntry, iTableEntryC 	= pxType^.NumSubs();
			var ^CAiNodeInstance 	pxNI;
	
			for(iTableEntry=0)cond(iTableEntry<iTableEntryC)iter(iTableEntry++)do
				var ^CPropDB.CNode		pxNode		= ^((pxType^)[iTableEntry]);
				var string				sClass		= pxNode^.Name();
				var string				sObjFlag	= "";
	
				if(pxNode^.NumSubs() > 0)then
					sObjFlag = (pxNode^)[0].Name();
				endif;
				
				if((sObjClass != sClass) || (sObjFlag != sObjObjFlag))then
					continue;
				endif;
				
				bFoundInTable = true;
				break;
			endfor;
			
			if(bFoundInTable == false)then continue; endif;
			
			pxNI = pxTT^.FindNodeInstance(p_pxUnitPool^[i]);
			if(pxNI == null)then continue; endif;
			
			if(pxNI^.NumSolutions() <= 0)then continue; endif;
			
			if(!pxNI^.IsDiscrete())then continue; endif;
			
			if(pxNI^.IsContained())then continue; endif;

			var real fE = CAiWeaponMgr.Get()^.GetFightEffectiveness(pxNI, pxTargetNI);
			if(fE < 0.0f)then continue; endif;
			
			var ^CObjSorter pxObjEntry = ^(axObjects.NewEntryRef());	
			pxObjEntry^.m_xObj				= p_pxUnitPool^[i];
			pxObjEntry^.m_fEffectiveness 	= fE;
		endfor;
		
		var int iFound = axObjects.NumEntries();
		if(iFound < 1)then return false; endif;
		
		axObjects.QSort();
		p_rxOW = axObjects[0].m_xObj;
		
		return true;		
	endproc;


	///GetNextGoodUnit
	export proc bool GetNextGoodUnit(ref CAiObjWrap p_rxOW, ^CAiObjWrapList p_pxUnitPool, ref CAiObjWrapList p_rxTargets, ref bool po_rbIsEfficient)
		po_rbIsEfficient = false;
		if(p_pxUnitPool == null)then return false; endif;
		
		if(p_pxUnitPool^.NumEntries() <= 0)then return false; endif;
		
		if(p_rxTargets.NumEntries() <= 0)then
			p_rxOW = p_pxUnitPool^[0];
			return true;
		endif;
		
		var bool bFound = false;
		while((bFound == false) && (p_rxTargets.NumEntries() > 0))do
			
			if((m_iTargetIdx >= p_rxTargets.NumEntries()) || (m_iTargetIdx < 0))then
				m_iTargetIdx = 0;
			endif;
			
			if((bFound = ComputeMostEfficientUnitForTarget(p_rxOW, p_pxUnitPool, p_rxTargets[m_iTargetIdx])) == false)then
				p_rxTargets.RemEntry(p_rxTargets[m_iTargetIdx]);
				m_iTargetIdx--;
			endif;
			
			m_iTargetIdx++;
		endwhile;
		
		if(p_rxTargets.NumEntries() <= 0)then
			p_rxOW = p_pxUnitPool^[0];
			po_rbIsEfficient = false;
		else
			po_rbIsEfficient = true;
		endif;
		
		return true;
	endproc;


	///SeparateBadFromGoodUnits
	export proc void SeparateBadFromGoodUnits(^CAiObjWrapList p_pxUnitPool, ref CAiObjWrapList p_rxBadUnits, ref CAiObjWrapList p_rxGoodUnits, int p_iLevel)

		var int						iLevel;
		var array CUnitsDescriptor	axUnitLevelDescs;
		var CAiObjWrapList			xTmpList;
		
		axUnitLevelDescs = 5;
		
		for(iLevel=0)cond(iLevel<5)iter(iLevel++)do
			ComputeCurrentAgeClasses(axUnitLevelDescs[iLevel], iLevel);
		endfor;
		
		QueryUnits(xTmpList, false);
			
		var int i, iC	= xTmpList.NumEntries();
		var int iObjLevel;
		
		for(i=0)cond(i<iC)iter(i++)do
			iObjLevel = xTmpList[i].GetAttribValueInt("level");
			
			if((iObjLevel < 0) || (iObjLevel > 4))then
				KLog.LogWarn("AiGoalMinistryOfDefense", "Obj "+xTmpList[i].GetName()+" has no level (and no captain) ("+iObjLevel.ToString()+") ignoring it... PlayerID: "+m_sPlayerID);
				continue;
			endif;
			
			if(axUnitLevelDescs[iObjLevel].m_asClasses.FindEntry(xTmpList[i].GetClassName()) == -1)then
				p_rxBadUnits.AddEntry(xTmpList[i]); //if not it is a bad unit
				xTmpList.RemEntry(xTmpList[i]);
				i--;
				iC--;
			endif;
		endfor;

		for(i=0)cond(i<iC)iter(i++)do
			var int iClassIdx = -1;
			
			iObjLevel = xTmpList[i].GetAttribValueInt("level");
			if((iObjLevel < 0) || (iObjLevel > 4))then
				continue;
			endif;
			
			if((iClassIdx = axUnitLevelDescs[iObjLevel].m_asClasses.FindEntry(xTmpList[i].GetClassName())) == -1)then
				continue;
			endif;
			
			if(axUnitLevelDescs[iObjLevel].m_iLevel != iObjLevel)then
				continue;
			endif;

			var int		iUnitCount		= axUnitLevelDescs[iObjLevel].m_aiUnitCounts[iClassIdx];
			var real	fCurUnitWeight	= 0.0;
			
			if(axUnitLevelDescs[iObjLevel].m_iAllUnitCount != 0)then
				fCurUnitWeight = (iUnitCount - 1).ToReal() / axUnitLevelDescs[iObjLevel].m_iAllUnitCount.ToReal();
			endif;
			
			var real	fWeightDiff		= fCurUnitWeight - axUnitLevelDescs[iObjLevel].m_afWeights[iClassIdx];
			
			if(fWeightDiff > 0.0)then
				p_rxBadUnits.AddEntry(xTmpList[i]); //if not it is a bad unit
				xTmpList.RemEntry(xTmpList[i]);
				i--;
				iC--;
			endif;
		
		endfor;

		p_rxGoodUnits.CopyFrom(xTmpList);
		if((p_iLevel >= 0) && (p_iLevel < 5))then
			
			iC = p_rxGoodUnits.NumEntries();
			for(i=0)cond(i<iC)iter(++i)do
				if(p_rxGoodUnits[i].GetAttribValueInt("level") != p_iLevel)then
					p_rxGoodUnits.RemEntry(p_rxGoodUnits[i]);
					i--;
					iC--;
				endif;
			endfor;
			
			iC = p_rxBadUnits.NumEntries();
			for(i=0)cond(i<iC)iter(++i)do
				if(p_rxBadUnits[i].GetAttribValueInt("level") != p_iLevel)then
					p_rxBadUnits.RemEntry(p_rxBadUnits[i]);
					i--;
					iC--;
				endif;
			endfor;
		
		endif;
	endproc;


	///QueryUnits
	export proc bool QueryUnits(ref CAiObjWrapList p_rxOWL, int p_iMin, int p_iMax, real p_fAllowedBadUnitWeight, int p_iMaxHeroCount, ref CAiObjWrapList p_rxTargets)
		return QueryUnits(p_rxOWL, p_iMin, p_iMax, p_fAllowedBadUnitWeight, p_iMaxHeroCount, p_rxTargets, -1, false);
	endproc;
	
	
	///QueryUnits
	export proc bool QueryUnits(ref CAiObjWrapList p_rxOWL, int p_iMin, int p_iMax, real p_fAllowedBadUnitWeight, int p_iMaxHeroCount, ref CAiObjWrapList p_rxTargets, int p_iLevel)
		return QueryUnits(p_rxOWL, p_iMin, p_iMax, p_fAllowedBadUnitWeight, p_iMaxHeroCount, p_rxTargets, p_iLevel, false);
	endproc;
	
	
	///QueryUnits
	export proc bool QueryUnits(ref CAiObjWrapList p_rxOWL, int p_iMin, int p_iMax, real p_fAllowedBadUnitWeight, int p_iMaxHeroCount, ref CAiObjWrapList p_rxTargets, int p_iLevel, bool p_bOnlyEfficient)
		if(m_pxBrain==null)then return false; endif;
		
		var ^CAiModuleDefenseDefault	pxDM;
		var ^CAiObjWrapList				pxUnitPool;
		var CAiObjWrapList				xBadUnits;
		var CAiObjWrapList				xGoodUnits;
		var CAiObjWrapList				xTmpTargets;
	
		pxDM=cast<CAiModuleDefenseDefault>(m_pxBrain^.GetDefenseModule());
		if(pxDM==null)then return false; endif;
		
		pxUnitPool=^(pxDM^.m_pxGoalGuardVillage^.GetUnitSupervisor().GetUnits());
		
		/*var ^CAiAllocationMgr pxAllocMgr = GetAiAllocationMgr();
		
		var CAiObjWrapList xTraUnits;
		var CAiObjQuery xQuery;
		
		xTraUnits.Clear();
		xQuery.SetOwner(m_iPlayerID);
		xQuery.SetType("CHTR");
		xQuery.SetType("ANML",true);
		xQuery.SetType("VHCL",true);
		
		xQuery.Execute(xTraUnits);
		
		var int iI, iC=xTraUnits.Validate();
		for(iI=0)cond(iI<iC)iter(iI++)do
			if((xTraUnits[iI].GetClassName().Find("worker")!=(-1))||(xTraUnits[iI].GetClassName().Find("resource_collector")!=(-1)))then
				xTraUnits.RemEntry(xTraUnits[iI]);
				iI--; iC--;
				continue;
			endif;
			if(m_pxSensor^.ComputeIslandId(xTraUnits[iI].GetPos())!=m_pxSensor^.ComputeIslandId(m_pxSensor^.GetStartLocation()))then
				xTraUnits.RemEntry(xTraUnits[iI]);
				iI--; iC--;
				continue;
			endif;
			if(pxAllocMgr!=null)then
				if(pxAllocMgr^.IsUnitLocked(xTraUnits[iI], false, false, true))then
					xTraUnits.RemEntry(xTraUnits[iI]);
					iI--; iC--;
					continue;
				endif;
			endif;
		endfor;
		
		pxUnitPool=^(xTraUnits);*/
				
		if(pxUnitPool^.Validate()<p_iMin)then return false; endif;
		
		SeparateBadFromGoodUnits(pxUnitPool, xBadUnits, xGoodUnits, p_iLevel);
		xTmpTargets.CopyFrom(p_rxTargets);
		m_iTargetIdx=0;
		
		var bool		bNoBadUnitLeft	= false;
		var int			i;
		var int			iBUFound		= 0;
		var int			iGUFound		= 0;
		var CAiObjWrap	xOW;
		
		for(i=0)cond(i<p_iMax)iter(i++)do
			var real fCurBadUnitWeight=(iBUFound + 1).ToReal() / (iBUFound + 1 + iGUFound).ToReal();
			if((fCurBadUnitWeight<=p_fAllowedBadUnitWeight)&&(bNoBadUnitLeft==false))then
				if(GetNextBadUnit(xOW, ^xBadUnits)==false)then
					bNoBadUnitLeft=true;
				else
					iBUFound++;
					p_rxOWL.AddEntry(xOW);
					xBadUnits.RemEntry(xOW);
					continue;
				endif;
			endif;
			
			var bool bIsEfficient;
			var bool bGUFound;
			
			bGUFound=GetNextGoodUnit(xOW, ^xGoodUnits, xTmpTargets, bIsEfficient);
			if(bGUFound==false)then			
				if((iBUFound+iGUFound)<p_iMin)then
					return false;
				endif;
				break;			
			endif;
			
			if((p_bOnlyEfficient)&&(!bIsEfficient))then
				fCurBadUnitWeight=(iBUFound+1).ToReal()/(iBUFound+1+iGUFound).ToReal();
				if(fCurBadUnitWeight<=p_fAllowedBadUnitWeight)then
					iGUFound--;
					iBUFound++;
				else
					if((iBUFound+iGUFound)<p_iMin)then
						return false;
					endif;
					break;
				endif;
			endif;
			
			iGUFound++;
			p_rxOWL.AddEntry(xOW);
			xGoodUnits.RemEntry(xOW); 
		endfor;
		
		RemoveUnitsFromPool(p_rxOWL);
		return true;
	endproc;
	
	
	///QueryEfficientUnits
	export proc bool QueryEfficientUnits(ref CAiObjWrapList p_rxOWL, int p_iMin, int p_iMax, ref CAiObjWrapList p_rxTargets)
		if(m_pxBrain==null) then return false; endif;
		
		var ^CAiModuleDefenseDefault	pxDM;
		var ^CAiObjWrapList				pxUnitPool;
		var CAiObjWrapList				xTmpList;
		var CAiObjWrapList				xTmpTargets;
		
		pxDM = cast<CAiModuleDefenseDefault>(m_pxBrain^.GetDefenseModule());
		if(pxDM == null)then return false; endif;
		
		pxUnitPool = ^(pxDM^.m_pxGoalGuardVillage^.GetUnitSupervisor().GetUnits());
		if(pxUnitPool^.NumEntries() < p_iMin)then
			return false;
		endif;
		
		QueryUnits(xTmpList, false);
		xTmpTargets.CopyFrom(p_rxTargets);
		m_iTargetIdx = 0;
		
		var int			i;
		var CAiObjWrap	xOW;
		
		for(i=0)cond(i<p_iMax)iter(i++)do
			var bool bIsEfficient;
			var bool bGUFound;
			
			bGUFound = GetNextGoodUnit(xOW, ^xTmpList, xTmpTargets, bIsEfficient);
			if((bGUFound == false) || (bIsEfficient == false))then			
				if(i < p_iMin)then
					return false;
				endif;
				break;			
			endif;
		
			p_rxOWL.AddEntry(xOW);
			xTmpList.RemEntry(xOW);
		endfor;
		
		RemoveUnitsFromPool(p_rxOWL);
		return true;
	endproc;


	///QueryUnits
	export proc void QueryUnits(ref CAiObjWrapList p_rxUnits, ^CAiNodeInstance p_pxNI, int p_iMin, int p_iMax)
		if(p_pxNI == null)then return; endif;
		p_rxUnits.Clear();

		if(m_pxBrain==null) then return; endif;
	
		var ^CAiModuleDefenseDefault	pxDM;		
		pxDM = cast<CAiModuleDefenseDefault>(m_pxBrain^.GetDefenseModule());
		if(pxDM == null)then return; endif;

		var CAiObjQuery		xOQ;
		var CAiObjQuery		xOQNonChars;
		var CAiObjWrapList	xNonCharUnits;
		var int				i, iC = p_pxNI^.GetFlags().NumEntries();
		
		for(i=0)cond(i<iC)iter(i++)do
			xOQ.SetAttribPos(p_pxNI^.GetFlags().GetNameByIndex(i), p_pxNI^.GetFlags().GetValueByIndex(i));
			xOQNonChars.SetAttribPos(p_pxNI^.GetFlags().GetNameByIndex(i), p_pxNI^.GetFlags().GetValueByIndex(i));
		endfor;
	
		xOQ.SetAttribPos("inventory_item_name", "");
		xOQ.SetClass(p_pxNI^.ComputeClassName());
		xOQNonChars.SetClass(p_pxNI^.ComputeClassName());
		xOQNonChars.SetType("ANML");
		xOQNonChars.SetType("VHCL", true);
		xOQNonChars.SetType("BLDG", true);
		xOQNonChars.SetType("SHIP", true);
		xOQ.Execute(pxDM^.m_pxGoalGuardVillage^.GetUnitSupervisor().GetUnits(), p_rxUnits);
		xOQNonChars.Execute(pxDM^.m_pxGoalGuardVillage^.GetUnitSupervisor().GetUnits(), xNonCharUnits);
		
		p_rxUnits.Include(xNonCharUnits);
		
		var int iDelete = p_rxUnits.NumEntries() - p_iMax;	
		if(iDelete > 0)then
			for(i=0)cond(i<iDelete)iter(i++)do
				if(p_rxUnits.NumEntries() <= 0)then
					break;
				endif;
				p_rxUnits.RemEntry(p_rxUnits[0]);
			endfor;
		endif;
		
		RemoveUnitsFromPool(p_rxUnits);
	endproc;


	///QueryUnits
	export proc bool QueryUnits(ref CAiObjWrapList p_rxUnits, int p_iMin, int p_iMax, ref CAiObjWrapList p_rxFrom)
		p_rxUnits.Clear();
		if(m_pxBrain==null) then return false; endif;
		
		var ^CAiModuleDefenseDefault	pxDM;
		var ^CAiObjWrapList				pxUnitPool;
		
		pxDM = cast<CAiModuleDefenseDefault>(m_pxBrain^.GetDefenseModule());
		if(pxDM == null)then return false; endif;
		
		pxUnitPool = ^(pxDM^.m_pxGoalGuardVillage^.GetUnitSupervisor().GetUnits());

		var int i, iC		= p_rxFrom.NumEntries();
		var int iUnitCount	= 0;
		
		for(i=0)cond(i<iC)iter(i++)do
			if(pxUnitPool^.FindEntry(p_rxFrom[i]) != -1)then
				p_rxUnits.Include(p_rxFrom[i]);
				iUnitCount++;
				if(iUnitCount >= p_iMax)then
					break;
				endif;
			endif;
		endfor;
		
		if(iUnitCount < p_iMin)then return false; endif;

		RemoveUnitsFromPool(p_rxUnits);
		return true;
	endproc;
	
	
	///QueryUnits
	export proc void QueryUnits(ref CAiObjWrapList p_rxUnits)
		QueryUnits(p_rxUnits, true);
	endproc;


	///QueryUnits
	export proc void QueryUnits(ref CAiObjWrapList p_rxUnits, bool p_bRemove)
		p_rxUnits.Clear();

		if(m_pxBrain==null) then return; endif;

		var ^CAiModuleDefenseDefault	pxDM;
		var ^CAiObjWrapList				pxUnitPool;
		
		pxDM = cast<CAiModuleDefenseDefault>(m_pxBrain^.GetDefenseModule());
		if(pxDM == null)then return; endif;
		pxUnitPool = ^(pxDM^.m_pxGoalGuardVillage^.GetUnitSupervisor().GetUnits());

		var CAiObjQuery		xOQ;
		var CAiObjQuery		xOQNonChars;
		var CAiObjWrapList	xNonCharUnits;

		xOQ.SetAttribPos("inventory_item_name", "");
		xOQNonChars.SetType("ANML");
		xOQNonChars.SetType("VHCL", true);
		xOQNonChars.SetType("BLDG", true);
		xOQNonChars.SetType("SHIP", true);
		xOQ.Execute(pxUnitPool^, p_rxUnits);

		xOQNonChars.Execute(pxUnitPool^, xNonCharUnits);
		p_rxUnits.Include(xNonCharUnits);

		if(p_bRemove == true)then
			RemoveUnitsFromPool(p_rxUnits);
		endif;
	endproc;
	
	
	///IsAllowedUnit
	export proc bool IsAllowedUnit(CAiObjWrap p_xObj)
		if(m_pxBrain==null) then return false; endif;
		if(m_pxSensor==null) then return false; endif;
		
		var ^CAiModuleControlDefault	pxCM;
		pxCM = cast<CAiModuleControlDefault>(m_pxBrain^.GetControlModule());
		if(pxCM==null)then return false;  endif;
		
		if(p_xObj.IsValid() == false)then return false; endif;
		
		if(p_xObj.GetClassName() == "hu_worker")then
			return false;
		elseif(p_xObj.GetClassName() == "aje_worker")then
			return false;
		elseif(p_xObj.GetClassName() == "ninigi_worker")then
			return false;
		elseif(p_xObj.GetClassName() == "seas_worker")then
			return false;
		elseif(p_xObj.GetClassName() == "aje_resource_collector")then
			return false;
		elseif(p_xObj.GetClassName() == "Virtual_Produce_Unit")then
			return false;
		elseif(p_xObj.GetClassName() == "hu_cart")then
			return false;
		elseif(p_xObj.GetClassName() == "ninigi_cart")then
			return false;
		elseif(p_xObj.GetClassName() == "aje_trade_dino")then
			return false;
		elseif(p_xObj.GetClassName() == "seas_triceratops_resource_collector")then
			return false;
		elseif(p_xObj.GetClassName() == "seas_hovercraft")then
			return false;
		elseif(p_xObj.GetClassName() == "aje_transport_turtle")then
			return false;
		elseif(p_xObj.GetClassName() == "aje_velociraptor")then
			return false;
		elseif(p_xObj.GetClassName() == "aje_tracker_dino")then
			return false;
		elseif(p_xObj.GetType() == "SHIP")then
			return false;
		elseif(p_xObj.GetType() == "BLDG")then
			return false;
		elseif(p_xObj.GetType() == "PROD")then
			return false;
		elseif((!p_xObj.GetCaptain(p_xObj))&&(p_xObj.GetClassName()=="ninigi_dilophosaurus"))then
			return false;
		elseif(p_xObj.GetClassName()=="hu_kennel_eusmilus")then
			return false;
		elseif(p_xObj.GetClassName()=="aje_kennel_eusmilus")then
			return false;
		elseif(p_xObj.GetClassName()=="ninigi_kennel_eusmilus")then
			return false;
		elseif(p_xObj.GetType() == "OTHR")then
			return false;
		elseif(p_xObj.GetType() == "PyCO")then
			return false;
		endif;
		
		var int iIslandId = m_pxSensor^.ComputeIslandId(p_xObj.GetPos());
		var int iHomeIslandId=m_pxSensor^.ComputeIslandId(m_pxSensor^.GetStartLocation());
		if(iIslandId != iHomeIslandId)then return false;endif;
		
		var CAiObjWrapList	xList = pxCM^.GetNPCMgr().GetAllNPCs(true);
		var int				i, iC = xList.Validate();
		var array string	asHeroes;

		for(i=0)cond(i<iC)iter(i++)do
			asHeroes.AddEntry(xList[i].GetClassName());
		endfor;
		
		if(asHeroes.FindEntry(p_xObj.GetClassName()) != -1)then return true; endif;
		
		if(p_xObj.GetClassName()=="special_eusmilus")then return true; endif;
	
		if(m_iAge<4)then
			var int iOP = m_pxSensor^.FindObjInOutpost(p_xObj);
			if(iOP != 0)then return false; endif;
		endif;
		
		if(p_xObj.GetAttribValueBool("is_riding"))then return false; endif;
		
		return true;
	endproc;

	
	///IsPyramidFull
	proc bool IsPyramidFull()
		if(m_pxSensor==null) then return false; endif;
		
		var ^CAiPyramid pxPyr = m_pxSensor^.GetPyramid();
		if(pxPyr == null)then return false; endif;
		
		var int i, iC = 5;
		for(i=0)cond(i<iC)iter(++i)do
			var int iMaxUnits = CAiPyramid.GetMaxUnits(i) - m_aiReservedLevelSlots[i];
			if(pxPyr^.GetNumUnits(i) < iMaxUnits)then
				return false;
			endif;
		endfor;
		return true;
	endproc;


	///AddUnitsToPool
	export proc void AddUnitsToPool(ref CAiObjWrapList p_rxUnits)
		if(m_pxBrain==null) then return; endif;

		var ^CAiModuleDefenseDefault	pxDM;
		var CAiObjWrapList				xAddList;
		
		pxDM = cast<CAiModuleDefenseDefault>(m_pxBrain^.GetDefenseModule());
		if(pxDM == null)then return; endif;
		
		var int i, iC = p_rxUnits.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do	
			if(!p_rxUnits[i].IsValid())then continue; endif;			
			
			if(IsAllowedUnit(p_rxUnits[i]))then
				xAddList.AddEntry(p_rxUnits[i]);
			else
				var ^CAiAllocationMgr	pxAllocMgr	= GetAiAllocationMgr();				
				if(pxAllocMgr==null)then continue; endif;
				pxAllocMgr^.ExternalUnlock(p_rxUnits[i]);
			endif;
		endfor;
		
		iC = xAddList.NumEntries();
		for(i=0)cond(i<iC)iter(++i)do
			var int iNumDefensePools = pxDM^.GetNumDefensePools();
			
			if(iNumDefensePools <= 0)then break; endif;
			
			if(m_iCurrentDefensePool < (iNumDefensePools - 1))then
				m_iCurrentDefensePool++;
			else
				m_iCurrentDefensePool = 0;
			endif;
			
			var ^CAiModuleDefenseDefault.CAiDefensePool pxDP=pxDM^.GetDefensePool(m_iCurrentDefensePool);
			if(pxDP==null) then continue; endif;
			
			var int iNumUnits=pxDP^.NumUnits();
			var int iMaxUnits=pxDP^.m_iMaxUnits;
			var string sId=pxDP^.m_sId;

			if((m_iCurrentDefensePool == 0) && (iMaxUnits != -1))then
				KLog.LogWarn("AiGoalMinistryOfDefense", "Defensepool 0 must not have a max unit cap (cap for DP0 is "+iMaxUnits.ToString()+") PlayerID: "+m_sPlayerID);
			endif;
			
			if((iMaxUnits != -1) && (iNumUnits >= iMaxUnits))then
				i--;
				continue;
			endif;
			
			var bool bQueued = pxDP^.AddUnit(xAddList[i]);
		endfor;
		
		if((iC > 0) && IsPyramidFull())then
			pxDM^.FlushAllDefensePools();
		endif;
		
	endproc;
	
	
	///RemoveUnitsFromPool
	export proc void RemoveUnitsFromPool(ref CAiObjWrapList p_rxUnits)
		if(m_pxBrain==null) then return; endif;
		var ^CAiModuleDefenseDefault	pxDM;
		
		pxDM = cast<CAiModuleDefenseDefault>(m_pxBrain^.GetDefenseModule());
		if(pxDM == null)then return; endif;
		
		pxDM^.m_pxGoalGuardVillage^.RemoveUnits(p_rxUnits, false);
	endproc;
	
	
	///ComputeFreeLevelSlots
	proc int ComputeFreeLevelSlots(int p_iLevel)
		var ^CAiTechTree		pxTT = GetAiTechTree();
		var ^CAiNodeInstance	pxNI;
		var CAiAttribs			xAttribs;
		var int					iInstanceCount;
		
		if(pxTT == null)then return 0; endif;		
		xAttribs.SetValue("level", p_iLevel.ToString());
		
		pxNI = pxTT^.GetNodeInstance("free_level", xAttribs);
		if(pxNI == null)then return 0; endif;
		
		iInstanceCount = pxNI^.GetInstanceCount();
		if(m_aiReservedLevelSlots.NumEntries() > p_iLevel)then
			return iInstanceCount - m_aiReservedLevelSlots[p_iLevel];
		endif;
		
		return 0;
	endproc;
	
	
	///ComputeUnitCount
	proc int ComputeUnitCount(string p_sClassName, ref CAiAttribs p_rxAttribs, int p_iLevel)
		if(m_pxBrain==null) then return 0; endif;
		
		var CAiObjQuery		xOQ;
		var CAiObjWrapList	xList;
		var int				i, iC = p_rxAttribs.NumEntries();
		
		for(i=0)cond(i<iC)iter(i++)do
			xOQ.SetAttribPos(p_rxAttribs.GetNameByIndex(i), p_rxAttribs.GetValueByIndex(i));
		endfor;

		var ^CAiModuleDefenseDefault	pxDM;
		pxDM = cast<CAiModuleDefenseDefault>(m_pxBrain^.GetDefenseModule());
		if(pxDM == null)then return 0; endif;
		
		xOQ.SetClass(p_sClassName);
		xOQ.Execute(pxDM^.m_pxGoalGuardVillage^.GetUnitSupervisor().GetUnits(), xList);
		
		return xList.NumEntries();
	endproc;
	
	
	///ComputeUnitCount
	proc int ComputeUnitCount(int p_iLevel)
		if(m_pxBrain==null) then return 0; endif;

		var ^CAiObjWrapList				pxList;
		var int							iCount	= 0;
		var ^CAiModuleDefenseDefault	pxDM;
	
		pxDM = cast<CAiModuleDefenseDefault>(m_pxBrain^.GetDefenseModule());
		if(pxDM == null)then return 0; endif;
		pxList = ^(pxDM^.m_pxGoalGuardVillage^.GetUnitSupervisor().GetUnits());

		var int	i, iC = pxList^.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(pxList^[i].IsValid())then
				if(pxList^[i].GetAttribValueInt("level") == p_iLevel)then
					iCount++;
				endif;
			endif;
		endfor;
		
		return iCount;
	endproc;
	
	
	///ComputeSolutionFromNI
	proc void ComputeSolutionFromNI(^CAiNodeInstance p_pxNI)
		if(p_pxNI == null)then return; endif;
		
		m_pxUnitNeed.GetNeed()^.Clear();
		m_pxUnitNeed.GetNeed()^.AddEntry(p_pxNI);
		
		if(m_xSolution.NumRequired() <= 0)then
			m_xSolution.AddRequired(m_pxUnitNeed);
		endif;
	
	endproc;
	
	
	///SpawnAddNextBestUnit
	export proc void SpawnAddNextBestUnit()
		ComputeNextBestUnitSolution(true);
	endproc;


	///ComputeNextBestUnitSolution
	proc bool ComputeNextBestUnitSolution()
		return ComputeNextBestUnitSolution(false);
	endproc;
	
	
	///ComputeNextBestUnitSolution
	proc bool ComputeNextBestUnitSolution(bool p_bSpawn)
		if(m_pxBrain==null) then return false; endif;
		if(m_pxSensor==null) then return false; endif;
		
		var string			sAgePath	= "Age_"+m_iAge.ToString();
		var ^CPropDB.CNode	pxAgeNode;
		var ^CAiTechTree	pxTT		= GetAiTechTree();
		var array string	asAvailableNPCs;
		
		if(pxTT == null)then return false; endif;
		pxAgeNode = ^(m_xUnitDB[sAgePath]);
		
		if(pxAgeNode == null)then return false; endif;
		
		GetAvailableNPCs(asAvailableNPCs);
		
		var bool			bFound = false;
		var int				iLevel;
		var string			sLevelPath = "Level_";
		var ^CPropDB.CNode	pxLevelNode;		
		var array ^CAiNodeInstance	apxNIs;
		var array int		aiUnitCounts;
		var array real		afWeights;
		var string			sPersonality = CAiUtilityMgr.Get()^.GetPersonality(m_pxBrain);
		var int				iDummy;
		
		for(iDummy=0)cond(iDummy<5)iter(++iDummy)do
			m_iCurChkLevel++;
			if(m_iCurChkLevel>4)then m_iCurChkLevel = 0; endif;
			
			iLevel = m_iCurChkLevel;
			pxLevelNode=^(m_xUnitDB[sAgePath+"/"+sLevelPath+(iLevel+1).ToString()]);
			if(pxLevelNode==null)then continue; endif;
			
			var int	i, iC=pxLevelNode^.NumSubs();
			var int	iFreeLevelSlots=ComputeFreeLevelSlots(iLevel);
			var real fWeightSum=0.0;
			var int	iUCSum=0;
			
			if((m_iAge==1)&&(ComputeUnitCount(iLevel)>=5)&&(p_bSpawn==false))then continue; endif;
			
			if((iFreeLevelSlots<=0)&&(p_bSpawn==false))then continue; endif;
			
			apxNIs = 0;
			aiUnitCounts = 0;
			afWeights = 0;
			
			for(i=0)cond(i<iC)iter(++i)do
				var ^CPropDB.CNode	pxGroupNode = ^((pxLevelNode^)[i]);
				var ^CAiNodeInstance pxNI = null;
				var int	iUnitSub, iUSubC = pxGroupNode^.NumSubs();
				var int	iUC	= 0;
				var real fWeight;
				
				for(iUnitSub=0)cond(iUnitSub<iUSubC)iter(iUnitSub++)do
					var ^CPropDB.CNode		pxUnitNode		= ^((pxGroupNode^)[iUnitSub]);
					var ^CPropDB.CNode		pxObjFlagNode	= pxUnitNode^.Get("ObjFlag");
					var string				sObjFlag;
					var CAiAttribs			xAttribs;
					
					if(pxObjFlagNode != null)then
						sObjFlag = pxObjFlagNode^.Value();
						if(sObjFlag.IsEmpty() == false)then
							xAttribs.SetValue("ObjFlag", sObjFlag);
						endif;
					endif;
					
					xAttribs.SetValue("level", iLevel.ToString());
					iUC += ComputeUnitCount(pxUnitNode^.Name(), xAttribs, iLevel);
					if((asAvailableNPCs.FindEntry(pxUnitNode^.Value()) == -1) && (pxUnitNode^.Value().IsEmpty() == false))then
						continue;
					endif;
					
					pxNI = pxTT^.GetNodeInstanceFromPartialName(pxUnitNode^.Name(), xAttribs);
					if(pxNI == null)then
						continue;
					endif;
				endfor;
				
				if(pxNI == null)then continue; endif;
				
				iUCSum += iUC;
				fWeight = pxGroupNode^.Value().ToReal();
				fWeightSum += fWeight;
				apxNIs.AddEntry(pxNI);
				aiUnitCounts.AddEntry(iUC);
				afWeights.AddEntry(fWeight);
			endfor;
			
			if(apxNIs.NumEntries() <= 0)then continue; endif;

			var real	fMinWeightDiff	= 1000000.0;
			var int		iBestIdx		= -1;

			iC = apxNIs.NumEntries();
			
			for(i=0)cond(i<iC)iter(i++)do
				var real fCurWeight;
				var real fWeightDiff;
				
				if(fWeightSum != 0.0)then
					afWeights[i] /= fWeightSum;
				endif;
				
				fCurWeight = 0.0;
				if(iUCSum != 0)then
					fCurWeight = aiUnitCounts[i].ToReal() / iUCSum.ToReal();
				endif;
				
				fWeightDiff = fCurWeight - afWeights[i];
				if(fWeightDiff < fMinWeightDiff)then
					fMinWeightDiff = fWeightDiff;
					iBestIdx = i;
				endif;
			
			endfor;
			
			if(iBestIdx < 0)then continue; endif;			
			if(p_bSpawn == true)then
				var ^CAiModuleControlDefault pxCM = cast<CAiModuleControlDefault>(m_pxBrain^.GetControlModule());
				if(pxCM == null)then
					
				else
					var CAiObjWrapList	xTmpList;
					var string			sClass = apxNIs[iBestIdx]^.ComputeClassName();
					var string			sObjFlag = apxNIs[iBestIdx]^.GetFlags().GetValue("ObjFlag");
					if(sObjFlag.IsEmpty() == false)then
						sClass+=":"+sObjFlag;
					endif;
					
					xTmpList.AddEntry(pxCM^.GetCheatMgr().SpawnUnit(sClass, GetAiSensor()^.GetOutpost(0).GetWorldPos()+{20.0,20.0,0.0}, {0.0, 0.0, 0.0}, iLevel)); //spawn needed unit
					if(xTmpList[0].IsValid() == false)then
						if(m_xAllocator.IsInitState() == true)then
							ComputeSolutionFromNI(apxNIs[iBestIdx]);
							m_xAllocator.SetSolution(^m_xSolution);
							m_xAllocator.SetOutpostId(0);
							m_xAllocator.SetRallyPos(m_pxSensor^.GetOutpost(0).GetWorldPos()+{20.0,20.0,0.0});
						endif;
					else
						AddUnitsToPool(xTmpList);
					endif;
				endif;
			else
				ComputeSolutionFromNI(apxNIs[iBestIdx]);
			endif;
			
			bFound = true;
			break;
		endfor;
		
		return bFound;
	endproc;
	
	
	///think
	export proc void Think()
		if(m_pxSensor==null) then return; endif;
		
		m_iAge=CAiUtilityMgr.Get()^.GetCurrentAge(m_pxBrain);
		
		if(m_bRefreshUnits) then
			RefreshUnits();
			m_bNow=true;
		endif;
				
		if(m_bNow)then
			if(m_iRefreshCounter==5)then
				ScheduleRefreshUnits();
				m_iRefreshCounter=0;
			endif;
			m_iRefreshCounter++;
		endif;
		
		if(m_xAllocator.IsInitState() == true)then
			var bool bCanProduce = ComputeNextBestUnitSolution();
			if(bCanProduce == false)then return; endif;
			
			m_xAllocator.SetSolution(^m_xSolution);
			m_xAllocator.SetOutpostId(0);
			m_xAllocator.SetRallyPos(m_pxSensor^.GetOutpost(0).GetWorldPos()+{20.0,20.0,0.0});

			if(m_xAllocator.Start(false))then return; endif;			
			if(m_xAllocator.Start(true))then return; endif;
		
		elseif(m_xAllocator.IsRunning() == true)then
			AddUnitsToPool(m_xAllocator.GetUnits());
			m_xAllocator.Shut();
			m_xAllocator.Init(this,false,false);
		
		elseif(m_xAllocator.IsStartState() == true)then
			if(m_xAllocator.GetUnits().NumEntries() > 0)then
				AddUnitsToPool(m_xAllocator.GetUnits());
				m_xAllocator.Shut();
				m_xAllocator.Init(this,false,false);
			endif;
		
		elseif(m_xAllocator.IsNotPossible())then
			m_xAllocator.Init(this,false,false);
			return;
		
		elseif(m_xAllocator.IsAborted())then
			m_xAllocator.Init(this,false,false);
			return;
		endif;
	
	endproc;


	///GetAvailableNPCs
	proc void GetAvailableNPCs(ref array string p_rasClasses)
		if(m_pxBrain==null) then return; endif;
		
		p_rasClasses = 0;
		var ^CAiModuleControlDefault pxCM=cast<CAiModuleControlDefault>(m_pxBrain^.GetControlModule());
		if(pxCM==null)then return; endif;

		var ^CAiNPCMgr pxNPCMgr = ^(pxCM^.GetNPCMgr());
		var CAiObjWrapList xList = pxNPCMgr^.GetAllNPCs();

		var int i, iC=xList.Validate();
		for(i=0)cond(i<iC)iter(i++)do
			var string sClass = xList[i].GetClassName();
			
			var int iLevel = xList[i].GetAttribValueInt("level");
			if(iLevel==4)then p_rasClasses.AddEntry(sClass); endif;		
		endfor;	
	endproc;

endclass;
