class CDockInfo
	var bool						m_bDocked;			///< indicates docking state
	var CObjHndl					m_xDockSite;		///< object docked to
	var procref<real,CObjHndl,bool>	m_xMoveCallback;

	export proc bool GetDocked()
		return m_bDocked;
	endproc;

	export proc CObjHndl GetDockSite()
		return m_xDockSite;
	endproc;

	export static proc bool GetEntryPos(CObjHndl p_xDocker,bool p_bWorld,bool p_bUp,ref vec3 po_rvPos)
		var ^CGameObj pxDocker=p_xDocker.GetObj();
		if(pxDocker==null)then return false; endif;
//		KLog.LogSpam("MaMa","docker present");
// HACK
		begin TestBrachio;
			var ^CTransportObj pxTO=cast<CTransportObj>(pxDocker);
			if(pxTO!=null)then
				if(!pxTO^.HasBuildUp(CBuildUpBase.TYPE_SIEGE))then return false; endif;
				var ^CGameObj pxBuildUp=pxTO^.GetBuildUp()^.GetPrimaryLinkedObj().GetObj();
				if(pxBuildUp==null)then return false; endif;
				var CFourCC xE="psh1";
				if(p_bUp)then
					xE="psh2";
				endif;
				if(p_bWorld)then
					return pxBuildUp^.GetLinkPosWorld(xE,po_rvPos);
				else
					return pxBuildUp^.GetLinkPosObj(xE,po_rvPos);
				endif;
			endif;
		end TestBrachio;
// END HACK
		var CFourCC xE="Wo_1";
		if(p_bUp)then
			xE="Wo_2";
		endif;
		if(p_bWorld)then
			return pxDocker^.GetLinkPosWorld(xE,po_rvPos);
		else
			return pxDocker^.GetLinkPosObj(xE,po_rvPos);
		endif;
	endproc;

	export proc bool SetDockedDocker(bool p_bDocked,CObjHndl p_xDocker)
		m_bDocked=p_bDocked;
		//KLog.LogWarn("CHP","SetDockedDocker: "+p_bDocked.ToString()+" "+m_xDockSite.GetObj()^.GetName());
		if(m_bDocked)then
			var vec3 vEntry;
			if(!GetEntryPos(p_xDocker,false,false,vEntry))then
//				KLog.LogSpam("MaMa","no entry pos found");
			endif;
			return CSrvWrap.GetObjMgr()^.GetObjPlaceChecker()^.GetWallMap()^.AddAdditionalEntrance(p_xDocker,m_xDockSite,vEntry,m_xMoveCallback);
		else
			CSrvWrap.GetObjMgr()^.GetObjPlaceChecker()^.GetWallMap()^.RemoveAdditionalEntrance(p_xDocker,m_xDockSite);
			return true;
		endif;
	endproc;

	export proc void SetDocked(bool p_bDocked,CObjHndl p_xDockSite)
		m_bDocked=p_bDocked;
		m_xDockSite=p_xDockSite;
	endproc;

	export proc void SetMoveCallback(procref<real,CObjHndl,bool> p_xMove)
		m_xMoveCallback=p_xMove;
	endproc;

	export proc void DoKArc(ref CArc p_rxArc)
		p_rxArc << m_bDocked;
		m_xDockSite.DoKArc(p_rxArc);
	endproc;
endclass;

class CDockWall inherit CTask
	var CObjHndl 	m_xDocker;
	var CObjHndl 	m_xWall;
	var CGameTime	m_xDockStart;
	var string 		m_sState;
	var vec3		m_vCurDest;
	var int			m_iFindCnt;
	var bool		m_bBroken;
	var ^CDockInfo	m_pxDockInfo;
	var string		m_sAnim;

	export constructor()
		SetName("DockWall");
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="DoWa";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,3);
		var ^CArc pxArc=^(pxWalk^.GetArc());		
		m_xDocker.DoKArc(pxArc^);
		m_xDockStart.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		(pxArc^) << m_vCurDest;
		(pxArc^) << m_iFindCnt;
		(pxArc^) << m_bBroken;
		m_xWall.DoKArc(pxArc^);
		(pxArc^) << m_sAnim;
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="DoWa")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xDocker.DoKArc(pxArc^);
			m_xDockStart.DoKArc(pxArc^);
			(pxArc^) << m_sState;
			(pxArc^) << m_vCurDest;
			(pxArc^) << m_iFindCnt;
			(pxArc^) << m_bBroken;
			if(pxArc^.GetVersion()>=2) then m_xWall.DoKArc(pxArc^); endif;
			if(pxArc^.GetVersion()>=3) then (pxArc^) << m_sAnim; endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;	

	export proc void Init(CObjHndl p_xDocker,^CDockInfo p_pxDockInfo,CObjHndl p_xWall)
		m_xDocker=p_xDocker;
		m_xWall=p_xWall;
		m_pxDockInfo = p_pxDockInfo;
		if(m_pxDockInfo!=null)then
			if(m_pxDockInfo^.GetDocked()&&m_pxDockInfo^.GetDockSite()==m_xWall)then
				m_sState="dock_wall";
				return;
			endif;
		endif;
		m_sState="find_pos";
	endproc;

	export proc ^CDockInfo GetDockInfo()
		return m_pxDockInfo;
	endproc;
	
	export proc void SetDockInfo(^CDockInfo p_pxDockInfo)
		m_pxDockInfo=p_pxDockInfo;
	endproc;

	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		if(m_pxDockInfo==null)then
			EndTask();
			return;
		elseif(m_pxDockInfo^.GetDocked())then
			m_sState="dock_wall";
		endif;
	endproc;

	proc void USLOnTick(int p_iTime)
		if(m_pxDockInfo==null)then
			EndTask();
			return;
		endif;

		//var ^CWall pxWall=cast<CWall>(m_pxDockInfo^.GetDockSite().GetObj());
		var ^CWall pxWall=cast<CWall>(m_xWall.GetObj());
		var ^CFightingObj pxDocker=cast<CFightingObj>(m_xDocker.GetObj());
		var ^CAttribs pxAttr = pxDocker^.GetAttribs();
		
		if(pxDocker==null)then EndTask(); return; endif;
		
		if(pxWall==null)then
			if(m_sState!="undock_wall"&&m_sState!="undocking"&&m_sState!="End") then
				m_sState="undock_wall";
			endif;
		endif;

		//KLog.LogWarn("CHP","State: "+m_sState);

		if(m_sState=="find_pos")then
			var vec3 vCurDest=pxWall^.GetPos();
			m_vCurDest=vCurDest;
			if(!CSrvWrap.GetObjMgr()^.GetObjPlaceChecker()^.GetWallMap()^.GetFreeDockPos(pxDocker^.GetOwner(),m_vCurDest,pxDocker^.GetPos())) then
				m_sState="End";
				return;
			endif;
			if(cast<CBrachiosaurus>(pxDocker)!=null)then
				vCurDest-=m_vCurDest;
				vCurDest.Normalize();
				vCurDest*=2.0f;
				m_vCurDest-=vCurDest;
			endif;
			if(cast<CSiegeTower>(pxDocker)!=null)then
				vCurDest-=m_vCurDest;
				vCurDest.Normalize();
				vCurDest*=3.0f;
				m_vCurDest+=vCurDest;
			endif;
			//CSrvWrap.GetObjMgr()^.GetFreePos(m_vCurDest,pxDocker,m_vCurDest);

			m_iFindCnt++;
			m_sState="goto_wall";
		elseif(m_sState=="goto_wall")then
			pxDocker^.WalkAction(m_vCurDest,pxDocker^.GetMaxSpeed());
			//pxDocker^.SetPos(m_vCurDest);
			m_sState="rotate_to_wall";
		elseif(m_sState=="rotate_to_wall")then
			if((m_vCurDest-pxDocker^.GetPos()).Abs2S()>4.0f)then
				if(m_iFindCnt>2)then
					EndTask();
					return;
				else
					m_sState="find_pos";
				endif;
			else
				var Quat qRot;
				var vec3 vDir=pxWall^.GetPos()-pxDocker^.GetPos();
				qRot.FromXYDir(vDir.GetX(),vDir.GetY());
				// there is no rotate anim
				if(cast<CBrachiosaurus>(pxDocker)!=null)then
					pxDocker^.RotateAction(qRot);
				elseif(cast<CSiegeTower>(pxDocker)!=null)then
					qRot.RotateZ(Math.Pi()*2.0);
					pxDocker^.RotateAction(qRot);
				else
					pxDocker^.SetRot(qRot);
				endif;
				m_sState="dock_wall";
			endif;
		elseif(m_sState=="dock_wall")then
			if (cast<CSiegeTower>(pxDocker)!=null) then
				m_sAnim = "opengate_moveup";
				if((pxWall^.GetClassName().Find("palisade")!=-1 && pxWall^.GetClassName().Find("ninigi_palisade")==-1) || pxWall^.GetClassName().Find("defense_skewer")!=-1 || pxWall^.GetClassName().Find("fence")!=-1)then
					m_sAnim = "opengate";
				endif;
				if(pxDocker^.HasAnim(m_sAnim))then
					pxDocker^.SetAnim(m_sAnim,1);
				endif;
			else
				var ^CTransportObj pxTO = cast<CTransportObj>(pxDocker);
				if (pxTO!=null) then
					if (pxTO^.HasAnim("siege")) then
						pxTO^.SetSLEAnim("siege", 1, true, false);
					endif;
					if(pxTO^.HasBuildUp(CBuildUpBase.TYPE_SIEGE))then
						var ^CGameObj pxSiege = pxTO^.GetBuildUp()^.GetPrimaryLinkedObj().GetObj();
						if (pxSiege!=null) then
							if (pxSiege^.HasAnim("siege_down")) then
								pxSiege^.SetAnim("siege_down", 1);
							endif;
						endif;
					endif;
				endif;
			endif;
			m_xDockStart=CTimeMgr.Get().GetTime();
			m_sState="docking";
		elseif(m_sState=="docking")then
			if((CTimeMgr.Get().GetTime()-m_xDockStart).GetSecondsF()>=2.0f)then
				if(m_bBroken)then
					m_sState="undock_wall";
				else
					m_pxDockInfo^.SetDocked(false,m_xWall);
					if(m_pxDockInfo^.SetDockedDocker(true,m_xDocker)) then
						m_sState="docked";
					else
						m_sState="undock_wall";
					endif;
				endif;
			endif;
		elseif(m_sState=="docked")then
			// don't tick while docked
			pxAttr^.SetValue("IsDockingWall", 1);
			GetFSM()^.Enable(false);
		elseif(m_sState=="undock_wall")then
			pxAttr^.SetValue("IsDockingWall", 0);
			if (cast<CSiegeTower>(pxDocker)!=null) then
				if(pxDocker^.HasAnim(m_sAnim))then
					pxDocker^.SetAnim(m_sAnim,2);
				endif;
			else
				var ^CTransportObj pxTO = cast<CTransportObj>(pxDocker);
				if (pxTO!=null) then
					if (pxTO^.HasAnim("siege")) then
						pxTO^.SetSLEAnim("siege", 1, false, true);
					endif;
					if(pxTO^.HasBuildUp(CBuildUpBase.TYPE_SIEGE))then
						var ^CGameObj pxSiege = pxTO^.GetBuildUp()^.GetPrimaryLinkedObj().GetObj();
						if (pxSiege!=null) then
							if (pxSiege^.HasAnim("siege_up")) then
								pxSiege^.SetAnim("siege_up", 1);
							endif;
						endif;
					endif;
				endif;
			endif;
			m_xDockStart=CTimeMgr.Get().GetTime();
			m_sState="undocking";
		elseif(m_sState=="undocking")then
			if((CTimeMgr.Get().GetTime()-m_xDockStart).GetSecondsF()>=2.0f)then
				m_pxDockInfo^.SetDockedDocker(false,m_xDocker);
				m_sState="End";
			endif;
		elseif(m_sState=="End")then
			pxAttr^.SetValue("IsDockingWall", 0);
			EndTask();
			return;
		endif;
	endproc;

	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
	endproc;

	export proc bool Break()
		m_bBroken=true;
		var ^CFightingObj pxDocker=cast<CFightingObj>(m_xDocker.GetObj());
		if(pxDocker!=null)then
			if(m_sState=="docked")then
				// undock from wall
				GetFSM()^.Enable(true);
				m_sState="undock_wall";
				return false;
			elseif((m_sState=="docking")||(m_sState=="undock_wall")||(m_sState=="undocking"))then
				// wait til undocked
				return false;
			endif;
		endif;
		m_sState="End";
		return true;
	endproc;

	export proc void Skip()
	endproc;

	proc void EndTask()
		UpdateAggressionPos(m_xDocker);
		super.EndTask();
	endproc;

endclass;

class CBuildLadder inherit CTask
	var CObjHndl	m_xWorker;		///< worker, who build the ladder
	var CObjHndl	m_xDockSite;	///< wall to build ladder to
	var string		m_sState;
	var vec3			m_vBuildPos;
	var vec3			m_vCurDest;
	var int				m_iFindCnt;
	var int				m_iCommandID;

	var CFourCC 	m_xFCCWeaponLink;

	export constructor()
		SetName("BuildUp"/*"BuildUpLadder"*/);
		m_iCommandID=-1;
		m_xFCCWeaponLink="HndR";
	endconstructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="BuLa";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());		
		m_xWorker.DoKArc(pxArc^);
		m_xDockSite.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		(pxArc^) << m_vBuildPos;
		(pxArc^) << m_vCurDest;
		(pxArc^) << m_iFindCnt;
		(pxArc^) << m_iCommandID;
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="BuLa")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xWorker.DoKArc(pxArc^);
			m_xDockSite.DoKArc(pxArc^);
			(pxArc^) << m_sState;
			(pxArc^) << m_vBuildPos;
			(pxArc^) << m_vCurDest;
			(pxArc^) << m_iFindCnt;
			(pxArc^) << m_iCommandID;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc void Init(CObjHndl p_xWorker,CObjHndl p_xDocksite)
		m_xWorker = p_xWorker;
		m_xDockSite = p_xDocksite;
		m_sState="find_pos";
	endproc;

	proc void USLOnTick(int p_iTime)
		var ^CWall pxWall=cast<CWall>(m_xDockSite.GetObj());
		var ^CFightingObj pxWorker=cast<CFightingObj>(m_xWorker.GetObj());

		if((pxWall==null)||(pxWorker==null))then EndTask(); return; endif;
		var ^CGameObj pxS=CSrvWrap.GetPathfinder().GetWallSiege(pxWall);
		if(pxS!=null) then
			KLog.LogWarn("CHP","Wall already sieged by: "+pxS^.GetName());
			EndTask();
			return;
		endif;

//		KLog.LogSpam("MaMa","State: "+m_sState+" CommandID: "+m_iCommandID.ToString());

		if(m_sState=="find_pos")then
			m_iCommandID=-1;//pxWorker^.GetCurrentMasterCommandID();
			m_vBuildPos=pxWall^.GetPos();
			CSrvWrap.GetObjMgr()^.GetObjPlaceChecker()^.GetWallMap()^.GetFreeDockPos(pxWorker^.GetOwner(),m_vBuildPos,pxWorker^.GetPos());
			m_vCurDest=m_vBuildPos;
			CSrvWrap.GetObjMgr()^.GetFreePos(m_vCurDest,pxWorker,m_vCurDest);
			m_iFindCnt++;
			m_sState="goto_wall";
		elseif(m_sState=="goto_wall")then
			pxWorker^.RemLinkGFX(m_xFCCWeaponLink);
			pxWorker^.SetLinkGFX(m_xFCCWeaponLink,"Hu_Clerk");

			var CFourCC xType="sldr";
			if(pxWorker^.GetOnWall())then
				pxWorker^.WallWalkAction(m_vCurDest,true,pxWorker^.GetMaxSpeed(),true,true,xType,false);
			else
				pxWorker^.WalkAction(m_vCurDest,pxWorker^.GetMaxSpeed(),true,true,null,xType);
			endif;
			m_sState="place_ladder";
		elseif(m_sState=="place_ladder")then
			if((m_vCurDest-pxWorker^.GetPos()).Abs2()>2.0f)then
				if(m_iFindCnt>2)then
					EndTask();
					return;
				else
					m_sState="find_pos";
				endif;
			else
				var ^CGameObj pxLadder=CLadder.GetLadderBuildUp(-1/*m_iCommandID*/).GetObj();
				if(pxLadder!=null)then
					pxWorker^.HandleGamePlayCommand("Q_Build",pxLadder,pxLadder^.GetPos(),"");
				else
					var vec3 vBuildPos=m_vBuildPos;
					var CObjList xWorker;
					xWorker.Include(pxWorker^.GetHandle());
					pxLadder=CPlaceMgr.Get().PlaceObj(pxWorker^.GetOwner(),"hu_ladder",m_vBuildPos,{0.0,0.0,0.0},xWorker,true,true).GetObj();
					if(pxLadder!=null)then
						CLadder.RegisterLadderBuildUp(-1/*m_iCommandID*/,pxLadder^.GetHandle());
						var vec3 vDir=pxWall^.GetPos()-vBuildPos;
						var Quat qRot;
						qRot.FromXYDir(vDir.GetX(),vDir.GetY());
						pxLadder^.SetRot(qRot);						
						var ^CLadder pxL = cast<CLadder>(pxLadder);
						if(pxL!=null) then
							pxL^.GetDockInfo().SetDocked(true, pxWall^.GetHandle());
						endif;
					endif;
				endif;
				EndTask();
				return;
			endif;
		endif;
	endproc;

	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		if(p_pxTo!=GetParent())then return; endif;
		var ^CGameObj pxWorker=m_xWorker.GetObj();
		if(pxWorker==null)then return; endif;
		pxWorker^.RemLinkGFX(m_xFCCWeaponLink);
	endproc;

endclass;

class CClimbLadder inherit CTask
	var CObjHndl	m_xWorker;
	var CObjHndl	m_xLadder;
	var bool		m_bClimbUp;
	var bool		m_bClimbForward;
	var bool		m_bJumpOff;
	var string		m_sState;
	var vec3		m_vEntry;
	var vec3		m_vExit;
	var vec3		m_vTop;
	var bool	m_bUnStoppable;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="ClLa";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,3);
		var ^CArc pxArc=^(pxWalk^.GetArc());		
		m_xWorker.DoKArc(pxArc^);
		m_xLadder.DoKArc(pxArc^);
		(pxArc^) << m_bUnStoppable;
		(pxArc^) << m_bClimbUp;
		(pxArc^) << m_sState;
		(pxArc^) << m_bClimbForward;
		(pxArc^) << m_vEntry;
		(pxArc^) << m_vExit;
		(pxArc^) << m_bJumpOff;
		(pxArc^) << m_vTop;
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ClLa")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xWorker.DoKArc(pxArc^);
			m_xLadder.DoKArc(pxArc^);
			(pxArc^) << m_bUnStoppable;
			(pxArc^) << m_bClimbUp;
			(pxArc^) << m_sState;
			if(pxArc^.GetVersion()>=2) then
				(pxArc^) << m_bClimbForward;
				(pxArc^) << m_vEntry;
				(pxArc^) << m_vExit;
			endif;
			if(pxArc^.GetVersion()>=3) then
				(pxArc^) << m_bJumpOff;
				(pxArc^) << m_vTop;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export constructor()
		m_bUnStoppable = false;
	endconstructor;
	
	export proc bool GetUnStoppable()
		return m_bUnStoppable;
	endproc;
	
	export proc void SetUnStoppable(bool p_bValue)
		m_bUnStoppable = p_bValue;
	endproc;

	export proc void Init(CObjHndl p_xWorker,CObjHndl p_xLadder,bool p_bClimbUp,bool p_bJumpOff)
		m_xWorker=p_xWorker;
		m_xLadder=p_xLadder;
		m_bClimbUp=p_bClimbUp;
		m_bClimbForward=true;
		m_bJumpOff=p_bJumpOff;
		m_sState="start";
	endproc;

	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CGameObj pxWorker=m_xWorker.GetObj();
		if(pxWorker==null)then EndTask();return; endif;
		pxWorker^.PauseAction();
	endproc;

	proc void USLOnTick(int p_iTime)
		var ^CCharacter pxWorker=cast<CCharacter>(m_xWorker.GetObj());
		var ^CGameObj pxLadder=m_xLadder.GetObj();

		if((pxWorker==null)||(pxLadder==null))then EndTask();return; endif;
		if(pxWorker^.HasSecondaryAction())then return; endif;
		//KLog.LogWarn("CHP","CClimbLadder::Tick State:"+m_sState);
		
		if(m_sState=="start")then
			var vec3 vDest;
			CDockInfo.GetEntryPos(m_xLadder,true,false,vDest);
			CDockInfo.GetEntryPos(m_xLadder,true,true,m_vTop);
			
			var vec3 vExit;
			var bool bFrontSide=true;
			if(GetExitPoint(pxWorker,pxLadder,vExit,bFrontSide)) then
				var vec3 vP=pxWorker^.GetPos();
				if(!bFrontSide) then
					m_bClimbForward=false;
					m_vEntry=vExit;
					m_vExit=vDest;
					m_vTop.SetX(m_vEntry.GetX());
					m_vTop.SetY(m_vEntry.GetY());
				else
					m_vEntry=vDest;
					m_vExit=vExit;
				endif;
				m_sState="trip";
			endif;
			if(m_sState=="start")then m_sState="end"; endif;
		endif;

		if(m_sState=="trip")then
			var vec3 vDest=m_vEntry;
			if(!pxWorker^.GetOnWall()&&(vDest-pxWorker^.GetPos()).Abs2S()>4.0f)then
				//pxWorker^.GoTo(vDest,true,pxWorker^.GetMaxSpeed(),true,true);
				pxWorker^.WalkAction(vDest,pxWorker^.GetMaxSpeed());
			endif;
			m_sState="trip_2";
		elseif(m_sState=="trip_2")then
			var vec3 vDest=m_vEntry;
			SetUnStoppable(true);
			pxWorker^.SetAnim("walk_3",3);
			pxWorker^.SecondaryMoveAction(vDest,5.0f);
			m_sState="rotate";
		elseif(m_sState=="rotate")then
			var Quat qRot=pxLadder^.GetRot();
			if(!m_bClimbForward)then
				qRot.RotateZ(Math.Pi());
			endif;
			pxWorker^.SecondaryRotateAction(qRot);
			m_sState="move";
		elseif(m_sState=="move")then
			var vec3 vDest=m_vTop;
			if(!m_bClimbForward)then
				pxWorker^.SetSLEAnim("hu_high_ladder_climb_up",2,true,true);
			else
				pxWorker^.SetSLEAnim("climb_down_ladder",2,true,true);
			endif;
			pxWorker^.SecondaryMoveAction(vDest,3.65f);
			if(m_bJumpOff)then
				m_sState="jump";
			else
				m_sState="trip_end";
			endif;
		elseif(m_sState=="trip_end")then
			var vec3 vDest=m_vTop;
				pxWorker^.SetAnim("walk_3",3);
			pxWorker^.SecondaryMoveAction(vDest,5.0f);
			m_sState="end";
		elseif(m_sState=="jump")then
			var vec3 vDest=m_vExit;
			if(pxWorker^.GetOnWall()) then EndTask(); return; endif;
			CSrvWrap.GetObjMgr()^.GetFreePos(vDest, pxWorker, vDest);
			pxWorker^.JumpAction("climb_up_ladder", vDest, pxWorker^.GetRot(), 0.0f, 20.0f);
			m_sState="end";
		elseif(m_sState=="end")then
			SetUnStoppable(false);
			EndTask();
		endif;
	endproc;

	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		var ^CGameObj pxWorker=m_xWorker.GetObj();
		if(pxWorker==null)then EndTask();return; endif;
		pxWorker^.UnpauseAction();
	endproc;

	proc void EndTask()
		UpdateAggressionPos(m_xWorker);
		GetFSM()^.Enable(false);
		super.EndTask();
	endproc;
	
	proc bool GetExitPoint(^CGameObj p_pxWorker,^CGameObj p_pxLadder,ref vec3 po_rvPos,ref bool po_rbFrontside)
		var ^CLadder pxL = cast<CLadder>(p_pxLadder);
		if(pxL==null) then return false; endif;
		var ^CGameObj pxWall=pxL^.GetDockInfo().GetDockSite().GetObj();
		if(pxWall==null) then return false; endif;

		var vec3 vPWorker=p_pxWorker^.GetPos();
		var vec3 vPWall=pxWall^.GetPos();
		var vec3 vPLadder=pxL^.GetPos();
		var vec3 vND = (vPWall-vPLadder).GetNormalized();
		
		var real fDB=((vPWall+vND)-vPWorker).AbsSquare();
		var real fDF=((vPWall-vND)-vPWorker).AbsSquare();
		po_rbFrontside=fDF<fDB;
		
		po_rvPos = pxWall^.GetPos() + (vND * 4.0f);
		po_rvPos.SetZ(CSrvWrap.GetScapeMgr().GetHeight(po_rvPos.GetX(), po_rvPos.GetY()));
		return true;
	endproc;

	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		return true;
	endproc;

endclass;

class CClimbBrachio inherit CTask
	var CObjHndl	m_xWorker;
	var CObjHndl	m_xBrachio;
	var bool		m_bClimbUp;
	var bool		m_bClimbForward;
	var bool		m_bJumpOff;
	var string		m_sState;
	var vec3		m_vEntry;
	var vec3		m_vExit;
	var vec3		m_vTop2;
	var vec3		m_vTop;
	var bool	m_bUnStoppable;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="ClBr";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());		
		m_xWorker.DoKArc(pxArc^);
		m_xBrachio.DoKArc(pxArc^);
		(pxArc^) << m_bUnStoppable;
		(pxArc^) << m_bClimbUp;
		(pxArc^) << m_sState;
		(pxArc^) << m_bJumpOff;
		(pxArc^) << m_bClimbForward;
		(pxArc^) << m_vEntry;
		(pxArc^) << m_vExit;
		(pxArc^) << m_vTop;
		(pxArc^) << m_vTop2;
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ClBr")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xWorker.DoKArc(pxArc^);
			m_xBrachio.DoKArc(pxArc^);
			(pxArc^) << m_bUnStoppable;
			(pxArc^) << m_bClimbUp;
			(pxArc^) << m_sState;
			if(pxArc^.GetVersion()>=2) then
				(pxArc^) << m_bJumpOff;
				(pxArc^) << m_bClimbForward;
				(pxArc^) << m_vEntry;
				(pxArc^) << m_vExit;
				(pxArc^) << m_vTop;
				(pxArc^) << m_vTop2;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export constructor()
		m_bUnStoppable = false;
	endconstructor;
	
	export proc bool GetUnStoppable()
		return m_bUnStoppable;
	endproc;
	
	export proc void SetUnStoppable(bool p_bValue)
		m_bUnStoppable = p_bValue;
	endproc;

	export proc void Init(CObjHndl p_xWorker,CObjHndl p_xBrachio,bool p_bClimbUp,bool p_bJumpOff)
		m_xWorker=p_xWorker;
		m_xBrachio=p_xBrachio;
		m_bClimbUp=p_bClimbUp;
		m_bJumpOff=p_bJumpOff;
		m_sState="start";
		m_bClimbForward=true;
	endproc;

	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CGameObj pxWorker=m_xWorker.GetObj();
		if(pxWorker==null)then EndTask();return; endif;
		pxWorker^.PauseAction();
	endproc;

	proc void USLOnTick(int p_iTime)
		var ^CCharacter pxWorker=cast<CCharacter>(m_xWorker.GetObj());
		var ^CGameObj pxBrachio=m_xBrachio.GetObj();

		if((pxWorker==null)||(pxBrachio==null))then EndTask();return; endif;
		if(pxWorker^.HasSecondaryAction())then return; endif;

		//KLog.LogWarn("CHP","CClimbBrachio::Tick State:"+m_sState);
		
		if(m_sState=="start")then
			var vec3 vDest;
			CDockInfo.GetEntryPos(m_xBrachio,true,false,vDest);
			CDockInfo.GetEntryPos(m_xBrachio,true,true,m_vTop);
			m_vEntry=vDest;
			
			var vec3 vExit;
			var bool bFrontSide=true;
			if(GetExitPoint(pxWorker,pxBrachio,vExit,bFrontSide)) then
				var vec3 vP=pxWorker^.GetPos();
				if(!bFrontSide) then
					m_bClimbForward=false;
					m_vEntry=vExit;
					m_vExit=vDest;
					m_vTop2=m_vTop;
					m_vTop.SetX(m_vEntry.GetX());
					m_vTop.SetY(m_vEntry.GetY());
				else
					m_vEntry=vDest;
					m_vExit=vExit;
					m_vTop2.SetX(m_vExit.GetX());
					m_vTop2.SetY(m_vExit.GetY());
					m_vTop2.SetZ(m_vTop.GetZ());
				endif;
			endif;
			m_sState="trip";
		endif;		

		if(m_sState=="trip")then
			var vec3 vDest=m_vEntry;
			if(!pxWorker^.GetOnWall()&&(vDest-pxWorker^.GetPos()).Abs2S()>4.0f) then
				//pxWorker^.GoTo(vDest,true,pxWorker^.GetMaxSpeed(),true,true);
				pxWorker^.WalkAction(vDest,pxWorker^.GetMaxSpeed());
			endif;
			m_sState="trip_2";
		elseif(m_sState=="trip_2")then
			var vec3 vDest=m_vEntry;
			SetUnStoppable(true);
			pxWorker^.SetAnim("walk_3",3);
			pxWorker^.SecondaryMoveAction(vDest,5.0f);
			m_sState="rotate";
		elseif(m_sState=="rotate")then
			var Quat qRot=pxBrachio^.GetRot();
			if(!m_bClimbForward)then
				qRot.RotateZ(Math.Pi());
			endif;
			pxWorker^.SecondaryRotateAction(qRot);
			m_sState="move1";
		elseif(m_sState=="move1")then
			if(m_bJumpOff&&m_vTop2.GetX()>=0.0) then
				var string sPre="all";
				if(m_bClimbForward) then
					var real fSpeed=(m_vExit-m_vEntry).Abs()/3.0f;
					pxWorker^.SetAnim("brachio_siege_up",1);
					pxWorker^.SecondaryMoveAction(m_vExit, fSpeed);
				else
					var real fSpeed=(m_vExit-m_vEntry).Abs()/3.6f;
					pxWorker^.SetAnim("brachio_siege_back",1);
					pxWorker^.SecondaryMoveAction(m_vExit, fSpeed);
				endif;
				m_sState="end";
				return;
			endif;

			var vec3 vDest=m_vTop;
			if(m_bClimbUp)then
				pxWorker^.SetAnim("climb_up_brachio",3);
			else
				pxWorker^.SetAnim("climb_down_brachio",3);
			endif;
			pxWorker^.SecondaryMoveAction(vDest, 3.65f);
			if(m_vTop2.GetX()>=0.0) then
				m_sState="move2";
			else
				m_sState="trip_end";
			endif;
		elseif(m_sState=="move2")then
			var vec3 vDest=m_vTop2;
			pxWorker^.SetAnim("climb_up_brachio",3);
			pxWorker^.SecondaryMoveAction(vDest, 3.65f);
			if(m_bJumpOff)then
				m_sState="jump";
			else
				m_sState="trip_end";
			endif;
		elseif(m_sState=="jump")then
			var vec3 vDest=m_vExit;
			if(!m_bClimbForward)then
				pxWorker^.SetAnim("climb_down_brachio",3);
				pxWorker^.SecondaryMoveAction(vDest, 3.65f);
				m_sState="end";
			else
				if(pxWorker^.GetOnWall()) then EndTask(); return; endif;
				CSrvWrap.GetObjMgr()^.GetFreePos(vDest, pxWorker, vDest);
				pxWorker^.JumpAction("climb_up_ladder", vDest, pxWorker^.GetRot(), 0.0f, 20.0f);
				m_sState="end";
			endif;
		elseif(m_sState=="trip_end")then
			var vec3 vDest;
			CDockInfo.GetEntryPos(m_xBrachio,true,m_bClimbUp,vDest);
			pxWorker^.SetAnim("walk_3",3);
			pxWorker^.SecondaryMoveAction(vDest,5.0f);
			m_sState="end";
		elseif(m_sState=="end")then
			SetUnStoppable(false);
			EndTask();
		endif;
	endproc;

	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		var ^CGameObj pxWorker=m_xWorker.GetObj();
		if(pxWorker==null)then EndTask();return; endif;
		pxWorker^.UnpauseAction();
	endproc;

	proc void EndTask()
		UpdateAggressionPos(m_xWorker);
		GetFSM()^.Enable(false);
		super.EndTask();
	endproc;
	
	proc bool GetExitPoint(^CGameObj p_pxWorker,^CGameObj p_pxBrachio,ref vec3 po_rvPos,ref bool po_rbFrontside)
		var ^CBrachiosaurus pxL = cast<CBrachiosaurus>(p_pxBrachio);
		if(pxL==null) then return false; endif;
		var ^CGameObj pxWall=pxL^.GetDockInfo().GetDockSite().GetObj();
		if(pxWall==null) then return false; endif;

		var vec3 vPWorker=p_pxWorker^.GetPos();
		var vec3 vPWall=pxWall^.GetPos();
		var vec3 vPLadder=pxL^.GetPos();
		var vec3 vND = (vPWall-vPLadder).GetNormalized();
		
		var real fDB=((vPWall+vND)-vPWorker).AbsSquare();
		var real fDF=((vPWall-vND)-vPWorker).AbsSquare();
		po_rbFrontside=fDF<fDB;
		
		po_rvPos = pxWall^.GetPos() + (vND * 4.0f);
		po_rvPos.SetZ(CSrvWrap.GetScapeMgr().GetHeight(po_rvPos.GetX(), po_rvPos.GetY()));
		return true;
	endproc;

	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		return true;
	endproc;

endclass;

class CClimbSiegeTower inherit CTask
	var CObjHndl	m_xWorker;
	var CObjHndl	m_xTower;
	var bool		m_bClimbForward;
	var string		m_sState;
	var vec3		m_vEntry;
	var vec3		m_vExit;
	var vec3		m_vTop2;
	var vec3		m_vTop;
	var bool	m_bUnStoppable;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="ClSt";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());		
		m_xWorker.DoKArc(pxArc^);
		m_xTower.DoKArc(pxArc^);
		(pxArc^) << m_bUnStoppable;
		(pxArc^) << m_sState;
		(pxArc^) << m_bClimbForward;
		(pxArc^) << m_vEntry;
		(pxArc^) << m_vExit;
		(pxArc^) << m_vTop;
		(pxArc^) << m_vTop2;
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ClSt")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xWorker.DoKArc(pxArc^);
			m_xTower.DoKArc(pxArc^);
			(pxArc^) << m_bUnStoppable;
			(pxArc^) << m_sState;
			(pxArc^) << m_bClimbForward;
			(pxArc^) << m_vEntry;
			(pxArc^) << m_vExit;
			(pxArc^) << m_vTop;
			(pxArc^) << m_vTop2;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export constructor()
		m_bUnStoppable = false;
	endconstructor;
	
	export proc bool GetUnStoppable()
		return m_bUnStoppable;
	endproc;
	
	export proc void SetUnStoppable(bool p_bValue)
		m_bUnStoppable = p_bValue;
	endproc;

	export proc void Init(CObjHndl p_xWorker,CObjHndl p_xTower)
		m_xWorker=p_xWorker;
		m_xTower=p_xTower;
		m_sState="start";
		m_bClimbForward=true;
	endproc;

	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CGameObj pxWorker=m_xWorker.GetObj();
		if(pxWorker==null)then EndTask();return; endif;
		pxWorker^.PauseAction();
	endproc;

	proc void USLOnTick(int p_iTime)
		var ^CCharacter pxWorker=cast<CCharacter>(m_xWorker.GetObj());
		var ^CGameObj pxTower=m_xTower.GetObj();
		var CObjHndl xWall;
		var ^CSiegeTower pxTwr = cast<CSiegeTower>(pxTower);
		if(pxTwr!=null) then
			xWall = pxTwr^.GetDockInfo().GetDockSite();
		endif;
		var ^CGameObj pxWall=xWall.GetObj();

		if((pxWorker==null)||(pxTower==null))then EndTask();return; endif;
		if(pxWorker^.HasSecondaryAction())then return; endif;

		//KLog.LogWarn("CHP","CClimbSiegeTower::Tick State:"+m_sState);
		
		if(m_sState=="start")then
			var vec3 vDest=pxTower^.GetPos();
			m_vEntry=vDest;
			m_vTop=vDest;
			m_vTop.SetZ(m_vTop.GetZ()+7.8f);
			
			var vec3 vExit;
			var bool bFrontSide=true;
			if(GetExitPoint(pxWorker,pxTower,vExit,bFrontSide)) then
				var vec3 vP=pxWorker^.GetPos();
				if(!bFrontSide) then
					m_bClimbForward=false;
					m_vEntry=vExit;
					m_vExit=vDest+(m_vExit-m_vEntry).GetNormalized()*3.0f;
					m_vTop2=m_vTop;
					m_vTop.SetX(m_vEntry.GetX());
					m_vTop.SetY(m_vEntry.GetY());
				else
					m_vEntry=vDest;
					m_vExit=vExit;
					m_vTop2.SetX(m_vExit.GetX());
					m_vTop2.SetY(m_vExit.GetY());
					m_vTop2.SetZ(m_vTop.GetZ());
				endif;
			endif;
			m_sState="trip";
		endif;		

		if(m_sState=="trip")then
			var vec3 vDest=m_vEntry;
			if(!pxWorker^.GetOnWall()&&(vDest-pxWorker^.GetPos()).Abs2S()>4.0f) then
				//pxWorker^.GoTo(vDest,true,pxWorker^.GetMaxSpeed(),true,true);
				pxWorker^.WalkAction(vDest,pxWorker^.GetMaxSpeed());
			endif;
			m_sState="rotate";
		elseif(m_sState=="rotate")then
			var Quat qRot=pxTower^.GetRot();
			qRot.RotateZ(Math.Pi());
			if(m_bClimbForward)then
				qRot.RotateZ(Math.Pi());
			endif;
			pxWorker^.SecondaryRotateAction(qRot);
			m_sState="trip_2";
		elseif(m_sState=="trip_2")then
			SetUnStoppable(true);
			var vec3 vDest=m_vEntry;
			pxWorker^.SetAnim("walk_3",3);
			pxWorker^.SecondaryMoveAction(vDest,5.0f);
			m_sState="move1";
		elseif(m_sState=="move1")then
			var vec3 vDest=m_vTop;
			if(!((pxWall^.GetClassName().Find("palisade")!=-1 && pxWall^.GetClassName().Find("ninigi_palisade")==-1) || pxWall^.GetClassName().Find("defense_skewer")!=-1) || pxWall^.GetClassName().Find("fence")!=-1)then
				vDest.SetZ(vDest.GetZ()+4.1f);
			endif;
			pxWorker^.SetAnim("climb_down_ladder",3);
			pxWorker^.SecondaryMoveAction(vDest,3.65f);
			m_sState="move2";
		elseif(m_sState=="move2")then
			var vec3 vDest=m_vTop2;
			if(!((pxWall^.GetClassName().Find("palisade")!=-1 && pxWall^.GetClassName().Find("ninigi_palisade")==-1) || pxWall^.GetClassName().Find("defense_skewer")!=-1) || pxWall^.GetClassName().Find("fence")!=-1)then
				vDest.SetZ(vDest.GetZ()+4.1f);
			endif;
			pxWorker^.SetSLEAnim("walk_2",3,true,true);
			pxWorker^.SecondaryMoveAction(vDest,3.65f);
			m_sState="jump";
		elseif(m_sState=="jump")then
			var vec3 vDest=m_vExit;
			if(pxWorker^.GetOnWall()) then EndTask(); return; endif;
			CSrvWrap.GetObjMgr()^.GetFreePos(vDest, pxWorker, vDest);
			pxWorker^.JumpAction("climb_up_ladder", vDest, pxWorker^.GetRot(), 0.0f, 20.0f);
			m_sState="end";
		elseif(m_sState=="end")then
			SetUnStoppable(false);
			EndTask();
		endif;
	endproc;

	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		var ^CGameObj pxWorker=m_xWorker.GetObj();
		if(pxWorker==null)then EndTask();return; endif;
		pxWorker^.UnpauseAction();
	endproc;

	proc void EndTask()
		UpdateAggressionPos(m_xWorker);
		GetFSM()^.Enable(false);
		super.EndTask();
	endproc;
	
	proc bool GetExitPoint(^CGameObj p_pxWorker,^CGameObj p_pxTower,ref vec3 po_rvPos,ref bool po_rbFrontside)
		var ^CSiegeTower pxL = cast<CSiegeTower>(p_pxTower);
		if(pxL==null) then return false; endif;
		var ^CGameObj pxWall=pxL^.GetDockInfo().GetDockSite().GetObj();
		if(pxWall==null) then return false; endif;

		var vec3 vPWorker=p_pxWorker^.GetPos();
		var vec3 vPWall=pxWall^.GetPos();
		var vec3 vPLadder=pxL^.GetPos();
		var vec3 vND = (vPWall-vPLadder).GetNormalized();
		
		var real fDB=((vPWall+vND)-vPWorker).AbsSquare();
		var real fDF=((vPWall-vND)-vPWorker).AbsSquare();
		po_rbFrontside=fDF<fDB;
		
		po_rvPos = pxWall^.GetPos() + (vND * 4.0f);
		po_rvPos.SetZ(CSrvWrap.GetScapeMgr().GetHeight(po_rvPos.GetX(), po_rvPos.GetY()));
		return true;
	endproc;	

	export proc bool Break()
		if(GetUnStoppable())then
			return false;
		endif;
		return true;
	endproc;

endclass;

class CLeaveSiegeTower inherit CTask
	var CObjHndl	m_xWorker;
	var CObjHndl	m_xSiege;
	var string		m_sState;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="LeST";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());		
		m_xWorker.DoKArc(pxArc^);
		m_xSiege.DoKArc(pxArc^);
		pxArc^ << m_sState;
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="LeST")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xWorker.DoKArc(pxArc^);
			m_xSiege.DoKArc(pxArc^);
			pxArc^ << m_sState;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc void Init(CObjHndl p_xWorker,CObjHndl p_xSiege)
		m_xWorker=p_xWorker;
		m_xSiege=p_xSiege;
		m_sState = "start";
	endproc;

	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CGameObj pxWorker=m_xWorker.GetObj();
		if(pxWorker==null)then EndTask();return; endif;
		pxWorker^.PauseAction();
	endproc;

	proc void USLOnTick(int p_iTime)
		var ^CCharacter pxWorker=cast<CCharacter>(m_xWorker.GetObj());
		var ^CGameObj pxSiege=m_xSiege.GetObj();

		if((pxWorker==null)||(pxSiege==null))then EndTask();return; endif;
		if(pxWorker^.HasSecondaryAction())then return; endif;

//		KLog.LogSpam("MaMa","CClimbBrachio::Tick State:"+m_sState);

		if(m_sState=="start")then
			var vec3 vDest;
			// set pos and rot
			m_sState="move";
		elseif(m_sState=="move")then
			var vec3 vDest;
			// move to ramp-tip
			m_sState="trip_end";
		elseif(m_sState=="trip_end")then
			var vec3 vDest;
			// jump down
			m_sState="jump";
		elseif(m_sState=="jump")then
			var vec3 vDest;
			var CObjHndl xWall;
			var ^CSiegeTower pxS = cast<CSiegeTower>(pxSiege);
			if(pxS!=null) then
				xWall = pxS^.GetDockInfo().GetDockSite();
			endif;

			var ^CGameObj pxWall=xWall.GetObj();
			if(pxWall==null) then EndTask(); return; endif;
			
			var vec3 vND = (pxWall^.GetPos()-pxSiege^.GetPos()).GetNormalized();
			vDest = pxWall^.GetPos() + (vND * pxWall^.GetRadius());
			vDest.SetZ(CSrvWrap.GetScapeMgr().GetHeight(vDest.GetX(), vDest.GetY()));
			CSrvWrap.GetObjMgr()^.GetFreePos(vDest, pxWorker, vDest);
			
			pxWorker^.SetPos(vDest);
			pxWorker^.JumpAction(pxWorker^.GetCaste()+"_climb_up_ladder", vDest, pxWorker^.GetRot(), 0.0f, 20.0f);
			m_sState="end";
		elseif(m_sState=="end")then
			EndTask();
		endif;
	endproc;

	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
		var ^CGameObj pxWorker=m_xWorker.GetObj();
		if(pxWorker==null)then EndTask();return; endif;
		pxWorker^.UnpauseAction();
	endproc;

	proc void EndTask()
		UpdateAggressionPos(m_xWorker);
		GetFSM()^.Enable(false);
		super.EndTask();
	endproc;

endclass;
