class CMickDundeeMove inherit CSpecialActionTask

	//Badgun Tuning: Stina Special Move
	const real	m_fDuration=20.0f;

	var CObjHndl	m_xMick;
	var CObjHndl	m_xAnimal;
	var string 		m_sState;
	var CGameTime	m_xTime;

	export constructor()
		SetName("MickDundeeMove");
		SetCivil(false);
	endconstructor;

	export destructor()
	enddestructor;
	
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="MDMo";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());		
		m_xMick.DoKArc(pxArc^);
		m_xAnimal.DoKArc(pxArc^);
		(pxArc^) << m_sState;
		m_xTime.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="MDMo")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xMick.DoKArc(pxArc^);
			m_xAnimal.DoKArc(pxArc^);
			(pxArc^) << m_sState;
			if(p_pxReaderNode^.GetVersion()>=2)then
				m_xTime.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc bool Init(CObjHndl p_xMick,CObjHndl p_xAnimal, string p_sPath)
		SetName("MickDundeeMove");
		m_xMick=p_xMick;
		m_xAnimal=p_xAnimal;
		SetSpecialActionPath(p_sPath);
		if(!m_xMick.IsValid()||(!m_xAnimal.IsValid()))then	return(false);endif;
		return(true);
	endproc;

	proc void USLOnEnter(^CState p_pxFrom, ^CState p_pxTo)
		var ^CFightingObj pxFightingObj=cast<CFightingObj>(m_xMick.GetObj());
		if(pxFightingObj==null || !pxFightingObj^.CheckSpecialActionTimer(GetSpecialActionPath()))then
			EndTask();
			return;
		endif;
	endproc;

	proc void USLOnTick(int p_iTime)
		if(!m_xMick.IsValid())then EndTask();return;endif;
		if(!m_xAnimal.IsValid())then	EndTask();return;endif;
		if(m_xMick==m_xAnimal)then EndTask();return;endif;

		var ^CAnimal pxAnimal=cast<CAnimal>(m_xAnimal.GetObj());
		var ^CAnimal pxMick=cast<CAnimal>(m_xMick.GetObj());
		if(pxAnimal==null)then EndTask();return;endif;
		if(pxMick==null)then EndTask();return;endif;
		
		if(m_sState!="prepare"&&m_sState!="end_anim")then
			if(IsInCombatRange())then
				if(!pxAnimal^.IsDead())then
					var vec3 vTarget=GetLookAtRot(pxAnimal^.GetPos()-pxMick^.GetPos());
					pxMick^.SetRotation(vTarget);
					m_sState="do_anim";
				endif;
			else
				if(pxMick^.GetMovableInFight()&&!pxMick^.GetOnWall())then
					pxMick^.AdvanceAction(pxAnimal^.GetHandle(),10.0,4);
				else
					EndTask();
					return;
				endif;
			endif;
		endif;
		if(m_sState=="do_anim")then
			if(!StartSpecialActionTimer(pxMick))then EndTask();return;endif;
			SetUnStoppable(true);
			pxMick^.SetAnim("sm_01",1);
			m_xTime = CTimeMgr.Get().GetTime();
			m_sState="prepare";
		elseif(m_sState=="prepare")then
			var CGameTime xNow = CTimeMgr.Get().GetTime();
			if((xNow-m_xTime).GetSecondsF()<2.6)then
				return;
			endif;
			var int iLoops = 1;
			var string sAnim="rest";
			if(!pxAnimal^.HasAnim("rest")&&pxAnimal^.HasAnim("sleep"))then
				sAnim="sleep";
			endif;
			if(pxAnimal^.HasAnim(sAnim))then
				var real fDuration = 0.0;
				while(fDuration<m_fDuration)do
					pxAnimal^.SetSLEAnim(sAnim, iLoops, true, true, fDuration);
					iLoops++;
				endwhile;
			endif;
			pxAnimal^.SetTrapped(m_fDuration);
			pxAnimal^.AnimAction(sAnim,iLoops,true,true);
			m_sState="end_anim";
		elseif(m_sState=="end_anim")then
			var CGameTime xNow = CTimeMgr.Get().GetTime();
			if((xNow-m_xTime).GetSecondsF()<3.4)then
				return;
			endif;
			SetUnStoppable(false);
			m_sState="EndTask";
			pxMick^.ReturnToFight();
			return;
		elseif(m_sState=="EndTask")then
			EndTask();
			return;
		endif;

	endproc;

	proc void USLOnLeave(^CState p_pxFrom, ^CState p_pxTo)
	endproc;

	export proc bool Break()
		if(m_xMick.IsValid())then
			m_xMick.GetObj()^.TerminateAction();
		endif;
		return true;
	endproc;

	//Checks if enemy is in combat range
	export proc bool IsInCombatRange()
		var ^CFightingObj pxMick=cast<CFightingObj>(m_xMick.GetObj());
		var ^CFightingObj pxAnimal=cast<CFightingObj>(m_xAnimal.GetObj());

		var real fFightDistance=pxAnimal^.GetRadius()+pxMick^.GetRadius();
		var real fDistVariance=10.0;
		return((pxMick^.GetPos()-pxAnimal^.GetPos()).Abs()<=fFightDistance+fDistVariance);
	endproc;

	export proc void EndTask()
		UpdateAggressionPos(m_xMick);
		super.EndTask();
	endproc;

endclass;
